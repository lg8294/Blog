{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/jacman/source/atom.xml","path":"atom.xml","modified":0,"renderable":1},{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/author.jpeg","path":"img/author.jpeg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/banner.jpeg","path":"img/banner.jpeg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/logo.jpeg","path":"img/logo.jpeg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/logo.svg","path":"img/logo.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/jacman.jpeg","path":"img/jacman.jpeg","modified":0,"renderable":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","path":"js/jquery.qrcode-0.12.0.min.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/banner.jpg","path":"img/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"7ac88f8ff77de8938a8b7cb5e0d4e2e7e0caa53c","modified":1524557378621},{"_id":"themes/jacman/.DS_Store","hash":"b1081a1935c12126886d12d30d54f210fb837625","modified":1531880618713},{"_id":"themes/jacman/.gitignore","hash":"7d65523f2a5afb69d76824dd1dfa62a34faa3197","modified":1526638074916},{"_id":"themes/jacman/LICENSE","hash":"931516aa36c53eb7843c83d82662eb50cc3c4367","modified":1526638074916},{"_id":"themes/jacman/README.md","hash":"098545637b0aeb27b14707c15e429470c603d78d","modified":1526638074917},{"_id":"themes/jacman/README_zh.md","hash":"9c73931bca4883de13eedd4be254da547d4ca52e","modified":1526638074917},{"_id":"themes/jacman/_config.yml","hash":"54cf1974d96a36617c29495bf50d2471fb70abbc","modified":1532678618648},{"_id":"themes/jacman/source/atom.xml","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1531882029785},{"_id":"source/_posts/ReactNative-iOS原生模块开发流程.md","hash":"5f8ccc5cc973444ce77954d616e1a145fbaeadf0","modified":1532675036989},{"_id":"source/_posts/dmg制作流程.md","hash":"f7bdd9a42234b1ce2af5fa4431b6ee41ca83faf8","modified":1532675075095},{"_id":"source/_posts/gitignore-语法规则.md","hash":"fb45c8253fad25af8e228a0b8521355a428650af","modified":1532673369629},{"_id":"source/_posts/iOS开发中关于库的版本号的研究.md","hash":"9815671802ade47cd010e9609a892d2e897915c1","modified":1524557352675},{"_id":"source/_posts/myfirstpost.md","hash":"927fe67e7222d7ec7396bb6db51af56b81c3014c","modified":1531900158102},{"_id":"source/_posts/使用Jenkins构建iOS应用并上传蒲公英.md","hash":"80648f164569ff2a21e318dcfb9a4bc18bdb1b0a","modified":1532674895295},{"_id":"source/_posts/常见证书格式及相互转换.md","hash":"9b9fa799dd363fa9f5ec0ae7abd82537c21c2813","modified":1524557352676},{"_id":"themes/jacman/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1526638074909},{"_id":"themes/jacman/.git/config","hash":"2d3ae691d19a816889480acb832a3813f5ad7605","modified":1526638074910},{"_id":"themes/jacman/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1526637903872},{"_id":"themes/jacman/.git/index","hash":"ba8aa74882d6ef6d4777852f0b5adb346a9c5a85","modified":1526638074947},{"_id":"themes/jacman/.git/packed-refs","hash":"872b592ab4bac2713bb4bfe4ab6c15f54c75eae1","modified":1526638074906},{"_id":"themes/jacman/languages/default.yml","hash":"eea72d6138497287c0b3f4bd93e4f6f62b7aff37","modified":1526638074918},{"_id":"themes/jacman/languages/zh-CN.yml","hash":"1f3b9d00dd4322352b0c9c82a76dc9865a616d41","modified":1526638074918},{"_id":"themes/jacman/languages/zh-TW.yml","hash":"61a02ba818d641579a86fcd7f5926ab1e6ab5f70","modified":1526638074918},{"_id":"themes/jacman/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1526638074925},{"_id":"themes/jacman/layout/index.ejs","hash":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1526638074925},{"_id":"themes/jacman/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1526638074925},{"_id":"themes/jacman/layout/layout.ejs","hash":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1526638074926},{"_id":"themes/jacman/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1526638074926},{"_id":"themes/jacman/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1526638074926},{"_id":"themes/jacman/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1526638074926},{"_id":"themes/jacman/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1526638074926},{"_id":"themes/jacman/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1526637903873},{"_id":"themes/jacman/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1526637903872},{"_id":"themes/jacman/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1526637903874},{"_id":"themes/jacman/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1526637903875},{"_id":"themes/jacman/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1526637903873},{"_id":"themes/jacman/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1526637903875},{"_id":"themes/jacman/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1526637903872},{"_id":"themes/jacman/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1526637903874},{"_id":"themes/jacman/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1526637903874},{"_id":"themes/jacman/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1526637903875},{"_id":"themes/jacman/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1526637903871},{"_id":"themes/jacman/.git/logs/HEAD","hash":"e8a7bded6f01768741e9c38cb58638280c71bd41","modified":1526638074910},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","hash":"3e1f1d8dc38b1e17c523d1176f7ee503fc648045","modified":1526638074918},{"_id":"themes/jacman/layout/_partial/analytics.ejs","hash":"697601996220fe0a0f9cd628be67dec3c86ae2aa","modified":1526638074919},{"_id":"themes/jacman/layout/_partial/archive.ejs","hash":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1526638074919},{"_id":"themes/jacman/layout/_partial/article.ejs","hash":"261ecacb8456f4cb972632b6a9103860fa63b9a3","modified":1526638074919},{"_id":"themes/jacman/layout/_partial/article_row.ejs","hash":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1526638074919},{"_id":"themes/jacman/layout/_partial/categories.ejs","hash":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1526638074919},{"_id":"themes/jacman/layout/_partial/footer.ejs","hash":"5f80bf6c6ddcf8c28c4599cd1540b14b25d54f18","modified":1526638074919},{"_id":"themes/jacman/layout/_partial/head.ejs","hash":"761941be4922cd3c177c8130296b909bf7db5c09","modified":1526638074919},{"_id":"themes/jacman/layout/_partial/header.ejs","hash":"18515612344ff048b9372b91b7eef6f3b143801f","modified":1526638074920},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","hash":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1526638074920},{"_id":"themes/jacman/layout/_partial/pagination.ejs","hash":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1526638074920},{"_id":"themes/jacman/layout/_partial/search.ejs","hash":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1526638074922},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","hash":"c4f527fff0070fbe65919053a16224412317f40d","modified":1526638074923},{"_id":"themes/jacman/layout/_partial/tags.ejs","hash":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1526638074923},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","hash":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1526638074923},{"_id":"themes/jacman/layout/_partial/totop.ejs","hash":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1526638074923},{"_id":"themes/jacman/layout/_widget/archive.ejs","hash":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1526638074924},{"_id":"themes/jacman/layout/_widget/category.ejs","hash":"c1fae96b5053da021bcc04ab2ce5c2c8d30de8a2","modified":1526638074924},{"_id":"themes/jacman/layout/_widget/douban.ejs","hash":"e3820c36169e88663e6c9177666b2904c1ce47e6","modified":1526638074924},{"_id":"themes/jacman/layout/_widget/github-card.ejs","hash":"d49a8d609c5fbafa9e7ad328163565af03306519","modified":1526638074924},{"_id":"themes/jacman/layout/_widget/links.ejs","hash":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1526638074924},{"_id":"themes/jacman/layout/_widget/rss.ejs","hash":"7625c761af68dd0c1118c0cef6748b0522c801db","modified":1532678555146},{"_id":"themes/jacman/layout/_widget/tag.ejs","hash":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1526638074925},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","hash":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1526638074925},{"_id":"themes/jacman/layout/_widget/weibo.ejs","hash":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1526638074925},{"_id":"themes/jacman/source/css/style.styl","hash":"a0a45af186a72ae68979bf26f2a5d0d2303189ca","modified":1526638074929},{"_id":"themes/jacman/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1526638074930},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1526638074930},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1526638074930},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1526638074930},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1526638074930},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1526638074930},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1526638074932},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1526638074932},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1526638074933},{"_id":"themes/jacman/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1526638074934},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1526638074934},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1526638074935},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1526638074936},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1526638074936},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1526638074938},{"_id":"themes/jacman/source/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1526638074939},{"_id":"themes/jacman/source/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1526638074940},{"_id":"themes/jacman/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1531879883519},{"_id":"themes/jacman/source/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1526638074940},{"_id":"themes/jacman/source/img/author.jpeg","hash":"008e800a2318ae2448f39c2d9dd83d33ca7cd313","modified":1531879753006},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1526638074943},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1526638074943},{"_id":"themes/jacman/source/img/banner.jpeg","hash":"391f914712644056398e2d8f8cde0daff8d092f3","modified":1531901150424},{"_id":"themes/jacman/source/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1526638074943},{"_id":"themes/jacman/source/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1526638074944},{"_id":"themes/jacman/source/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1526638074944},{"_id":"themes/jacman/source/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1526638074944},{"_id":"themes/jacman/source/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1526638074944},{"_id":"themes/jacman/source/img/logo.jpeg","hash":"d9504dea6c2707ed2168cf4ea2dc2175c83ca739","modified":1531879866881},{"_id":"themes/jacman/source/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1526638074945},{"_id":"themes/jacman/source/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1526638074945},{"_id":"themes/jacman/source/img/jacman.jpeg","hash":"564cdb63dabf70808e5e1542336dbe99769031b8","modified":1531879896344},{"_id":"themes/jacman/source/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1526638074945},{"_id":"themes/jacman/source/img/favicon.ico","hash":"323ded26fa7dab682f7af3aee8d68eac4b46091d","modified":1516936954000},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1526638074946},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1526638074946},{"_id":"themes/jacman/source/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1526638074947},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1526638074935},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1526638074938},{"_id":"themes/jacman/source/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1526638074939},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1526638074946},{"_id":"themes/jacman/.git/refs/heads/master","hash":"cdf7ebb26811b17304103dcf164bb82b88b4f841","modified":1526638074909},{"_id":"themes/jacman/.git/objects/pack/pack-469f62c841c9e4887c9c338e6fdb0743493db10c.idx","hash":"58c44d7ca5b830acc931c036e8fecea1d5f5eb92","modified":1526638074892},{"_id":"themes/jacman/layout/_partial/post/article.ejs","hash":"b09e3acea7076e1f01dfe0c2295e19951ea09437","modified":1526638074920},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","hash":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1526638074920},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","hash":"548c69c570d5aac567bc6f088e9ee0c02223b088","modified":1526638074921},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","hash":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1526638074921},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","hash":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1526638074921},{"_id":"themes/jacman/layout/_partial/post/header.ejs","hash":"36a705942b691abe0d643ea8afa339981b32f6f2","modified":1526638074922},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","hash":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1526638074922},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","hash":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1526638074922},{"_id":"themes/jacman/source/css/_base/font.styl","hash":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1526638074926},{"_id":"themes/jacman/source/css/_base/public.styl","hash":"f016180726019927b9a835ed01e04d153f27a149","modified":1526638074927},{"_id":"themes/jacman/source/css/_base/variable.styl","hash":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1526638074927},{"_id":"themes/jacman/source/css/_partial/article.styl","hash":"c69641b4a34a8c62986b335414413dbde26de25e","modified":1526638074927},{"_id":"themes/jacman/source/css/_partial/aside.styl","hash":"506fde1d67ce750452cbe84bee01a19c7d027c5e","modified":1526638074928},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","hash":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1526638074928},{"_id":"themes/jacman/source/css/_partial/footer.styl","hash":"1911613a19b605a58f801c21b03b5d4c83b90f9c","modified":1526638074928},{"_id":"themes/jacman/source/css/_partial/gallery.styl","hash":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1526638074928},{"_id":"themes/jacman/source/css/_partial/header.styl","hash":"5121ceb712be3f2dde98b8b6e589b546e19eab8f","modified":1526638074929},{"_id":"themes/jacman/source/css/_partial/helper.styl","hash":"1136600932b97534b88465bf05ef313630b2de3d","modified":1526638074929},{"_id":"themes/jacman/source/css/_partial/index.styl","hash":"a72ff14effd276015264f870f47ed8f8413bf5d3","modified":1526638074929},{"_id":"themes/jacman/source/css/_partial/totop.styl","hash":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1526638074929},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1526638074931},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1526638074931},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1526638074931},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1526638074931},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1526638074931},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1526638074932},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1526638074937},{"_id":"themes/jacman/source/img/banner.jpg","hash":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1526638074942},{"_id":"themes/jacman/.git/logs/refs/heads/master","hash":"e8a7bded6f01768741e9c38cb58638280c71bd41","modified":1526638074910},{"_id":"themes/jacman/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1526638074908},{"_id":"themes/jacman/source/css/_base/highlight/highlight.styl","hash":"91b62bfc58390b0d5db782a75be6965ee3665eb3","modified":1526638074927},{"_id":"themes/jacman/source/css/_base/highlight/theme.styl","hash":"e3a59bd427ba37a54ead9eeba9a5356b3f720a48","modified":1526638074927},{"_id":"themes/jacman/.git/logs/refs/remotes/origin/HEAD","hash":"e8a7bded6f01768741e9c38cb58638280c71bd41","modified":1526638074908},{"_id":"themes/jacman/.git/objects/pack/pack-469f62c841c9e4887c9c338e6fdb0743493db10c.pack","hash":"be0f4cac310ca35ed9e731c3da88ee87d0ddfa32","modified":1526638074891},{"_id":"source/_posts/iOS-面试题汇总.md","hash":"26ce41695cd15c75ecbd5f03453cf15a15a150ad","modified":1570678094003},{"_id":"public/atom.xml","hash":"df006187e343203b3b5688a66f9fcee8581df4a5","modified":1570678119747},{"_id":"public/archives/index.html","hash":"e8d9dbfcd32dbab15280ea06e44078a4b58a18a6","modified":1570678119805},{"_id":"public/archives/2017/index.html","hash":"e6498e3cd2193623675807aba9e3f548d069e60a","modified":1570678119806},{"_id":"public/archives/2017/08/index.html","hash":"c6a79bbef3296f8dc532be9fceb63be473d2143b","modified":1570678119806},{"_id":"public/archives/2017/09/index.html","hash":"deb1267e301486068bb3b4ede909224135e18a1c","modified":1570678119806},{"_id":"public/archives/2018/index.html","hash":"15c194024d6baa787ccda9a1cb28cf4287b128ef","modified":1570678119806},{"_id":"public/archives/2018/07/index.html","hash":"97d03d043b224b13327b3bfa699931ba556a08bf","modified":1570678119806},{"_id":"public/index.html","hash":"2f1c05de2c7d980b8f57f6d416b7b35a2ee8ae16","modified":1570678119807},{"_id":"public/tags/iOS/index.html","hash":"f9414973d289a4b9f9b2b6665058c2b570f4a186","modified":1570678119807},{"_id":"public/tags/证书/index.html","hash":"fdb49b7b50ecdb56443a758f909aeb14ea6705e0","modified":1570678119807},{"_id":"public/2018/07/27/dmg制作流程/index.html","hash":"82a062b40db05b5ad323f85807d5ce2b081cb2ca","modified":1570678119807},{"_id":"public/2018/07/27/ReactNative-iOS原生模块开发流程/index.html","hash":"52049769e11937ab7269c6ef68c32ad86e90710e","modified":1570678119807},{"_id":"public/2018/07/27/使用Jenkins构建iOS应用并上传蒲公英/index.html","hash":"2596bcf29ac805b8e58c3bcb8463c08e5ba91fd3","modified":1570678119807},{"_id":"public/2018/07/27/gitignore-语法规则/index.html","hash":"48c9eb43938e2aafd5a5f39dc3da1978c14aed7f","modified":1570678119807},{"_id":"public/2017/09/06/iOS开发中关于库的版本号的研究/index.html","hash":"7f2800d7d72d74b97666f3180c0d146faf5ba9e0","modified":1570678119808},{"_id":"public/2017/08/16/常见证书格式及相互转换/index.html","hash":"71aaab7a96a475328884014ea0c2e5645cdaeab3","modified":1570678119808},{"_id":"public/2017/08/09/myfirstpost/index.html","hash":"64cb07267e8b02c7068ad20426c96998fa91c42a","modified":1570678119808},{"_id":"public/archives/2019/index.html","hash":"46bc5e9f0a6d7792474f215f4862af67f7e4d337","modified":1570678119811},{"_id":"public/archives/2019/10/index.html","hash":"8397dbaebc1ccb9588e8a8b510fe936a4eddfaea","modified":1570678119811},{"_id":"public/2019/10/10/iOS-面试题汇总/index.html","hash":"66afed99c06431587faeb03f32ba0ca8d7299e13","modified":1570678119811}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"ReactNative iOS原生模块开发流程","date":"2018-07-27T06:51:36.000Z","_content":"# ReactNative iOS原生模块开发流程\n\n最近要开发 RN 的组件，查看了官方原生组件的开发说明文档，发现侧重点是在编写原生代码这部分，缺少环境的搭建流程，所以查了一些资料，整理一个环境搭建的流程。\n\n整个流程基本上分以下几步：\n\n1. 创建 RN 项目（用来调试模块）；\n2. 创建原生模块项目；\n3. RN 项目中引入原生模块项目；\n4. 开发原生模块（参照 RN 官方文档）；\n5. 发布上线；\n\n## 创建 RN 工程\n\n首先通过 CLI 创建一个 RN 项目，在开发原生模块的过程中会用这个工程来进行调试。\n\n```sh\nreact-native init ExampleModule\n```\n\n## 创建原生模块项目\n\n通过网上的资料，我发现创建原生模块项目有2种简便方法，通过2种方式创建项目，可以省去手动配置项目的工作，极大的减少可能出错的环节。\n\n### 通过 RN 的 CLI 创建\n\n```sh\n#react-native new-library --name <yourLibraryName>\n```\n\n命令执行后，可以在`./Libraries`下面找到创建的原生项目，**这种方式只支持 iOS 项目**。\n\n### 通过 react-native-create-library 来创建\n\n1. 安装`react-native-create-library`；\n\n    ```\n    npm install -g react-native-create-library\n    ```\n\n2. 进入你要存放原生模块的目录（建议是 `Libraries`），执行下面的命令；\n\n    ```sh\n    react-native-create-library <yourLibraryName>\n    ```\n\n这种方式创建的项目中包含`iOS`、`Android`、`Windows`三个文件夹，对应三个平台。如果是开发跨平台的模块，建议使用这种方式。\n\n## RN 项目中引入原生模块项目\n\n这里只是开发 `iOS` 模块，所以直接使用方式一创建原生模块项目。`ExampleModule` 是 RN 项目，`MyFirstRNModule` 是原生模块。现在文件结构如下图：\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245383675028.jpg)\n\n用 `xcode` 打开 `ExampleModule/ios` 下的 iOS 工程，添加 `MyFirstRNModule` 到`Libraries` 文件夹下，如下图：\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245390726193.jpg)\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245391049749.jpg)\n\n链接 `MyFristRNModule` 到 `ExampleModule` 工程中：\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245394525224.jpg)\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245394784670.jpg)\n\n至此，RN 项目就引入了原生模块项目。\n\n## 编写原生模块代码\n\n这一部分按照 [RN 官方教程](http://facebook.github.io/react-native/docs/native-modules-ios.html)来编写原生模块代码。\n\n在这里只做个简单的测试，看是否可以调用到这个模块。\n\n1. 打开`MyFirstRNModule.m`文件，添加代码，然后使用模拟器运行；\n\n    ![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245402331526.jpg)\n\n2. 修改 RN 项目中的`App.js`；\n\n    ![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245408646258.jpg)\n\n3. 选中模拟器，`cmd+R` 刷新界面；\n\n    ![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245409912857.jpg)\n\n4. 点击 `test` 按键，注意观察 xcode 的调试窗口，这时会打印一条 `test` 信息出来，说明模块运行正确；\n\n    ![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245415527519.jpg)\n\n\n## 发布上线\n\n编写好原生模块之后，就可以发布到 npm，这样其他人就可以下载使用。\n\n1. 创建模块的 GitHub 仓库\n2. 修改模块的入口文件\n\n    目录下已经有了 `MyFirstRNModule.ios.js` 可以作为入口文件，但是发布到 npm 上的包都是以 `index.js` 作为入口文件的，因此创建 `index.js`，将原生模块导出。\n\n    ```js\n    import React, { NativeModules } from 'react-native';\n    module.exports = NativeModules.MyFirstRNModule;\n    ```\n\n3. 发布到 npm\n\n    发布之前，需要先编辑 `package.json` 来配置原生模块的信息，如下：\n\n    ```json\n    {\n      \"name\": \"my-first-rn-module\",\n      \"version\": \"0.0.1\",\n      \"main\": \"index.js\",\n      \"keywords\": \"react-native\",\n      \"author\": \"lg\",\n      \"license\": \"MIT\",\n      \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/lg8294/MyFirstRNModule.git\"\n      },\n      \"homepage\": \"https://github.com/lg8294/MyFirstRNModule\",\n      \"bugs\": {\n        \"url\": \"https://github.com/lg8294/MyFirstRNModule/issues\"\n      }\n    }\n    ```\n\n    注：其中的 `name` 要采用 `kebab-case` 格式，否则发布的时候会报错。\n    如果编写的原生模块依赖于其他的原生模块，需要在 package.json 添加依赖关系，这里由于没有相关依赖，所以不需要添加：\n\n    ```json\n    \"dependencies\": {\n    }\n    ```\n\n    如果没有npm的账号，先注册一个账号，这个账号会被添加到npm本地的配置中，用来发布module用。\n\n    ```sh\n    npm adduser\n    Username: your name\n    Password: your password\n    Email: yourmail@gmail.com\n    ```\n\n    发布：\n    \n    ```sh\n    npm publish\n    ```\n\n    有时候，有些文件没必要发布，例如 MyFirstRNModule.ios.js 和 MyFirstRNModule.android.js 文件，可以通过 .npmignore 忽略它。例如我这里 .npmignore 文件内容如下：\n    \n    ```\n    .git\n    .gitignore\n    MyFirstRNModule.ios.js\n    MyFirstRNModule.android.js\n    ```\n\n4. 添加 README\n\n    README 文件是非常重要的，如果没有 README 文件，别人看到这个组件，根本就不知道它是用来做什么的。所以，很有必要添加一个 README 文件，这个文件需要告诉别人这个原生组件是干什么的、如何安装、API、使用手册等等。\n\n## 参考文档\n\n[React Native 原生模块库打包指南](https://chasecs.github.io/2017/08/09/react_native_packing_native_module_for_android_n_ios.html)\n[ReactNative之原生模块开发并发布——iOS篇](http://www.liuchungui.com/blog/2016/05/02/reactnativezhi-yuan-sheng-mo-kuai-kai-fa-bing-fa-bu-iospian/)\n[如何创建React Native iOS原生模块](http://www.devio.org/2017/01/22/React-Native-iOS%E5%8E%9F%E7%94%9F%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-%E6%95%99%E7%A8%8B-%E5%BF%83%E5%BE%97/)\n","source":"_posts/ReactNative-iOS原生模块开发流程.md","raw":"---\ntitle: ReactNative iOS原生模块开发流程\ndate: 2018-07-27 14:51:36\ntags:\n---\n# ReactNative iOS原生模块开发流程\n\n最近要开发 RN 的组件，查看了官方原生组件的开发说明文档，发现侧重点是在编写原生代码这部分，缺少环境的搭建流程，所以查了一些资料，整理一个环境搭建的流程。\n\n整个流程基本上分以下几步：\n\n1. 创建 RN 项目（用来调试模块）；\n2. 创建原生模块项目；\n3. RN 项目中引入原生模块项目；\n4. 开发原生模块（参照 RN 官方文档）；\n5. 发布上线；\n\n## 创建 RN 工程\n\n首先通过 CLI 创建一个 RN 项目，在开发原生模块的过程中会用这个工程来进行调试。\n\n```sh\nreact-native init ExampleModule\n```\n\n## 创建原生模块项目\n\n通过网上的资料，我发现创建原生模块项目有2种简便方法，通过2种方式创建项目，可以省去手动配置项目的工作，极大的减少可能出错的环节。\n\n### 通过 RN 的 CLI 创建\n\n```sh\n#react-native new-library --name <yourLibraryName>\n```\n\n命令执行后，可以在`./Libraries`下面找到创建的原生项目，**这种方式只支持 iOS 项目**。\n\n### 通过 react-native-create-library 来创建\n\n1. 安装`react-native-create-library`；\n\n    ```\n    npm install -g react-native-create-library\n    ```\n\n2. 进入你要存放原生模块的目录（建议是 `Libraries`），执行下面的命令；\n\n    ```sh\n    react-native-create-library <yourLibraryName>\n    ```\n\n这种方式创建的项目中包含`iOS`、`Android`、`Windows`三个文件夹，对应三个平台。如果是开发跨平台的模块，建议使用这种方式。\n\n## RN 项目中引入原生模块项目\n\n这里只是开发 `iOS` 模块，所以直接使用方式一创建原生模块项目。`ExampleModule` 是 RN 项目，`MyFirstRNModule` 是原生模块。现在文件结构如下图：\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245383675028.jpg)\n\n用 `xcode` 打开 `ExampleModule/ios` 下的 iOS 工程，添加 `MyFirstRNModule` 到`Libraries` 文件夹下，如下图：\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245390726193.jpg)\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245391049749.jpg)\n\n链接 `MyFristRNModule` 到 `ExampleModule` 工程中：\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245394525224.jpg)\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245394784670.jpg)\n\n至此，RN 项目就引入了原生模块项目。\n\n## 编写原生模块代码\n\n这一部分按照 [RN 官方教程](http://facebook.github.io/react-native/docs/native-modules-ios.html)来编写原生模块代码。\n\n在这里只做个简单的测试，看是否可以调用到这个模块。\n\n1. 打开`MyFirstRNModule.m`文件，添加代码，然后使用模拟器运行；\n\n    ![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245402331526.jpg)\n\n2. 修改 RN 项目中的`App.js`；\n\n    ![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245408646258.jpg)\n\n3. 选中模拟器，`cmd+R` 刷新界面；\n\n    ![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245409912857.jpg)\n\n4. 点击 `test` 按键，注意观察 xcode 的调试窗口，这时会打印一条 `test` 信息出来，说明模块运行正确；\n\n    ![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245415527519.jpg)\n\n\n## 发布上线\n\n编写好原生模块之后，就可以发布到 npm，这样其他人就可以下载使用。\n\n1. 创建模块的 GitHub 仓库\n2. 修改模块的入口文件\n\n    目录下已经有了 `MyFirstRNModule.ios.js` 可以作为入口文件，但是发布到 npm 上的包都是以 `index.js` 作为入口文件的，因此创建 `index.js`，将原生模块导出。\n\n    ```js\n    import React, { NativeModules } from 'react-native';\n    module.exports = NativeModules.MyFirstRNModule;\n    ```\n\n3. 发布到 npm\n\n    发布之前，需要先编辑 `package.json` 来配置原生模块的信息，如下：\n\n    ```json\n    {\n      \"name\": \"my-first-rn-module\",\n      \"version\": \"0.0.1\",\n      \"main\": \"index.js\",\n      \"keywords\": \"react-native\",\n      \"author\": \"lg\",\n      \"license\": \"MIT\",\n      \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/lg8294/MyFirstRNModule.git\"\n      },\n      \"homepage\": \"https://github.com/lg8294/MyFirstRNModule\",\n      \"bugs\": {\n        \"url\": \"https://github.com/lg8294/MyFirstRNModule/issues\"\n      }\n    }\n    ```\n\n    注：其中的 `name` 要采用 `kebab-case` 格式，否则发布的时候会报错。\n    如果编写的原生模块依赖于其他的原生模块，需要在 package.json 添加依赖关系，这里由于没有相关依赖，所以不需要添加：\n\n    ```json\n    \"dependencies\": {\n    }\n    ```\n\n    如果没有npm的账号，先注册一个账号，这个账号会被添加到npm本地的配置中，用来发布module用。\n\n    ```sh\n    npm adduser\n    Username: your name\n    Password: your password\n    Email: yourmail@gmail.com\n    ```\n\n    发布：\n    \n    ```sh\n    npm publish\n    ```\n\n    有时候，有些文件没必要发布，例如 MyFirstRNModule.ios.js 和 MyFirstRNModule.android.js 文件，可以通过 .npmignore 忽略它。例如我这里 .npmignore 文件内容如下：\n    \n    ```\n    .git\n    .gitignore\n    MyFirstRNModule.ios.js\n    MyFirstRNModule.android.js\n    ```\n\n4. 添加 README\n\n    README 文件是非常重要的，如果没有 README 文件，别人看到这个组件，根本就不知道它是用来做什么的。所以，很有必要添加一个 README 文件，这个文件需要告诉别人这个原生组件是干什么的、如何安装、API、使用手册等等。\n\n## 参考文档\n\n[React Native 原生模块库打包指南](https://chasecs.github.io/2017/08/09/react_native_packing_native_module_for_android_n_ios.html)\n[ReactNative之原生模块开发并发布——iOS篇](http://www.liuchungui.com/blog/2016/05/02/reactnativezhi-yuan-sheng-mo-kuai-kai-fa-bing-fa-bu-iospian/)\n[如何创建React Native iOS原生模块](http://www.devio.org/2017/01/22/React-Native-iOS%E5%8E%9F%E7%94%9F%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-%E6%95%99%E7%A8%8B-%E5%BF%83%E5%BE%97/)\n","slug":"ReactNative-iOS原生模块开发流程","published":1,"updated":"2018-07-27T07:03:56.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1k3jkt80000jz6ydf0xeult","content":"<h1 id=\"ReactNative-iOS原生模块开发流程\"><a href=\"#ReactNative-iOS原生模块开发流程\" class=\"headerlink\" title=\"ReactNative iOS原生模块开发流程\"></a>ReactNative iOS原生模块开发流程</h1><p>最近要开发 RN 的组件，查看了官方原生组件的开发说明文档，发现侧重点是在编写原生代码这部分，缺少环境的搭建流程，所以查了一些资料，整理一个环境搭建的流程。</p>\n<p>整个流程基本上分以下几步：</p>\n<ol>\n<li>创建 RN 项目（用来调试模块）；</li>\n<li>创建原生模块项目；</li>\n<li>RN 项目中引入原生模块项目；</li>\n<li>开发原生模块（参照 RN 官方文档）；</li>\n<li>发布上线；</li>\n</ol>\n<h2 id=\"创建-RN-工程\"><a href=\"#创建-RN-工程\" class=\"headerlink\" title=\"创建 RN 工程\"></a>创建 RN 工程</h2><p>首先通过 CLI 创建一个 RN 项目，在开发原生模块的过程中会用这个工程来进行调试。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">react-native init ExampleModule</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建原生模块项目\"><a href=\"#创建原生模块项目\" class=\"headerlink\" title=\"创建原生模块项目\"></a>创建原生模块项目</h2><p>通过网上的资料，我发现创建原生模块项目有2种简便方法，通过2种方式创建项目，可以省去手动配置项目的工作，极大的减少可能出错的环节。</p>\n<h3 id=\"通过-RN-的-CLI-创建\"><a href=\"#通过-RN-的-CLI-创建\" class=\"headerlink\" title=\"通过 RN 的 CLI 创建\"></a>通过 RN 的 CLI 创建</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#react-native new-library --name &lt;yourLibraryName&gt;</span></span><br></pre></td></tr></table></figure>\n<p>命令执行后，可以在<code>./Libraries</code>下面找到创建的原生项目，<strong>这种方式只支持 iOS 项目</strong>。</p>\n<h3 id=\"通过-react-native-create-library-来创建\"><a href=\"#通过-react-native-create-library-来创建\" class=\"headerlink\" title=\"通过 react-native-create-library 来创建\"></a>通过 react-native-create-library 来创建</h3><ol>\n<li><p>安装<code>react-native-create-library</code>；</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g react-native-create-library</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>进入你要存放原生模块的目录（建议是 <code>Libraries</code>），执行下面的命令；</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">react-native-create-library &lt;yourLibraryName&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这种方式创建的项目中包含<code>iOS</code>、<code>Android</code>、<code>Windows</code>三个文件夹，对应三个平台。如果是开发跨平台的模块，建议使用这种方式。</p>\n<h2 id=\"RN-项目中引入原生模块项目\"><a href=\"#RN-项目中引入原生模块项目\" class=\"headerlink\" title=\"RN 项目中引入原生模块项目\"></a>RN 项目中引入原生模块项目</h2><p>这里只是开发 <code>iOS</code> 模块，所以直接使用方式一创建原生模块项目。<code>ExampleModule</code> 是 RN 项目，<code>MyFirstRNModule</code> 是原生模块。现在文件结构如下图：</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245383675028.jpg\" alt></p>\n<p>用 <code>xcode</code> 打开 <code>ExampleModule/ios</code> 下的 iOS 工程，添加 <code>MyFirstRNModule</code> 到<code>Libraries</code> 文件夹下，如下图：</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245390726193.jpg\" alt></p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245391049749.jpg\" alt></p>\n<p>链接 <code>MyFristRNModule</code> 到 <code>ExampleModule</code> 工程中：</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245394525224.jpg\" alt></p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245394784670.jpg\" alt></p>\n<p>至此，RN 项目就引入了原生模块项目。</p>\n<h2 id=\"编写原生模块代码\"><a href=\"#编写原生模块代码\" class=\"headerlink\" title=\"编写原生模块代码\"></a>编写原生模块代码</h2><p>这一部分按照 <a href=\"http://facebook.github.io/react-native/docs/native-modules-ios.html\" target=\"_blank\" rel=\"noopener\">RN 官方教程</a>来编写原生模块代码。</p>\n<p>在这里只做个简单的测试，看是否可以调用到这个模块。</p>\n<ol>\n<li><p>打开<code>MyFirstRNModule.m</code>文件，添加代码，然后使用模拟器运行；</p>\n<p> <img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245402331526.jpg\" alt></p>\n</li>\n<li><p>修改 RN 项目中的<code>App.js</code>；</p>\n<p> <img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245408646258.jpg\" alt></p>\n</li>\n<li><p>选中模拟器，<code>cmd+R</code> 刷新界面；</p>\n<p> <img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245409912857.jpg\" alt></p>\n</li>\n<li><p>点击 <code>test</code> 按键，注意观察 xcode 的调试窗口，这时会打印一条 <code>test</code> 信息出来，说明模块运行正确；</p>\n<p> <img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245415527519.jpg\" alt></p>\n</li>\n</ol>\n<h2 id=\"发布上线\"><a href=\"#发布上线\" class=\"headerlink\" title=\"发布上线\"></a>发布上线</h2><p>编写好原生模块之后，就可以发布到 npm，这样其他人就可以下载使用。</p>\n<ol>\n<li>创建模块的 GitHub 仓库</li>\n<li><p>修改模块的入口文件</p>\n<p> 目录下已经有了 <code>MyFirstRNModule.ios.js</code> 可以作为入口文件，但是发布到 npm 上的包都是以 <code>index.js</code> 作为入口文件的，因此创建 <code>index.js</code>，将原生模块导出。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; NativeModules &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = NativeModules.MyFirstRNModule;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>发布到 npm</p>\n<p> 发布之前，需要先编辑 <code>package.json</code> 来配置原生模块的信息，如下：</p>\n <figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"my-first-rn-module\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"version\"</span>: <span class=\"string\">\"0.0.1\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"main\"</span>: <span class=\"string\">\"index.js\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"keywords\"</span>: <span class=\"string\">\"react-native\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"author\"</span>: <span class=\"string\">\"lg\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"license\"</span>: <span class=\"string\">\"MIT\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"repository\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"git\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"url\"</span>: <span class=\"string\">\"https://github.com/lg8294/MyFirstRNModule.git\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"homepage\"</span>: <span class=\"string\">\"https://github.com/lg8294/MyFirstRNModule\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"bugs\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"url\"</span>: <span class=\"string\">\"https://github.com/lg8294/MyFirstRNModule/issues\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 注：其中的 <code>name</code> 要采用 <code>kebab-case</code> 格式，否则发布的时候会报错。<br> 如果编写的原生模块依赖于其他的原生模块，需要在 package.json 添加依赖关系，这里由于没有相关依赖，所以不需要添加：</p>\n <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"dependencies\": &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 如果没有npm的账号，先注册一个账号，这个账号会被添加到npm本地的配置中，用来发布module用。</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm adduser</span><br><span class=\"line\">Username: your name</span><br><span class=\"line\">Password: your password</span><br><span class=\"line\">Email: yourmail@gmail.com</span><br></pre></td></tr></table></figure>\n<p> 发布：</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm publish</span><br></pre></td></tr></table></figure>\n<p> 有时候，有些文件没必要发布，例如 MyFirstRNModule.ios.js 和 MyFirstRNModule.android.js 文件，可以通过 .npmignore 忽略它。例如我这里 .npmignore 文件内容如下：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.git</span><br><span class=\"line\">.gitignore</span><br><span class=\"line\">MyFirstRNModule.ios.js</span><br><span class=\"line\">MyFirstRNModule.android.js</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加 README</p>\n<p> README 文件是非常重要的，如果没有 README 文件，别人看到这个组件，根本就不知道它是用来做什么的。所以，很有必要添加一个 README 文件，这个文件需要告诉别人这个原生组件是干什么的、如何安装、API、使用手册等等。</p>\n</li>\n</ol>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://chasecs.github.io/2017/08/09/react_native_packing_native_module_for_android_n_ios.html\" target=\"_blank\" rel=\"noopener\">React Native 原生模块库打包指南</a><br><a href=\"http://www.liuchungui.com/blog/2016/05/02/reactnativezhi-yuan-sheng-mo-kuai-kai-fa-bing-fa-bu-iospian/\" target=\"_blank\" rel=\"noopener\">ReactNative之原生模块开发并发布——iOS篇</a><br><a href=\"http://www.devio.org/2017/01/22/React-Native-iOS%E5%8E%9F%E7%94%9F%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-%E6%95%99%E7%A8%8B-%E5%BF%83%E5%BE%97/\" target=\"_blank\" rel=\"noopener\">如何创建React Native iOS原生模块</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ReactNative-iOS原生模块开发流程\"><a href=\"#ReactNative-iOS原生模块开发流程\" class=\"headerlink\" title=\"ReactNative iOS原生模块开发流程\"></a>ReactNative iOS原生模块开发流程</h1><p>最近要开发 RN 的组件，查看了官方原生组件的开发说明文档，发现侧重点是在编写原生代码这部分，缺少环境的搭建流程，所以查了一些资料，整理一个环境搭建的流程。</p>\n<p>整个流程基本上分以下几步：</p>\n<ol>\n<li>创建 RN 项目（用来调试模块）；</li>\n<li>创建原生模块项目；</li>\n<li>RN 项目中引入原生模块项目；</li>\n<li>开发原生模块（参照 RN 官方文档）；</li>\n<li>发布上线；</li>\n</ol>\n<h2 id=\"创建-RN-工程\"><a href=\"#创建-RN-工程\" class=\"headerlink\" title=\"创建 RN 工程\"></a>创建 RN 工程</h2><p>首先通过 CLI 创建一个 RN 项目，在开发原生模块的过程中会用这个工程来进行调试。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">react-native init ExampleModule</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建原生模块项目\"><a href=\"#创建原生模块项目\" class=\"headerlink\" title=\"创建原生模块项目\"></a>创建原生模块项目</h2><p>通过网上的资料，我发现创建原生模块项目有2种简便方法，通过2种方式创建项目，可以省去手动配置项目的工作，极大的减少可能出错的环节。</p>\n<h3 id=\"通过-RN-的-CLI-创建\"><a href=\"#通过-RN-的-CLI-创建\" class=\"headerlink\" title=\"通过 RN 的 CLI 创建\"></a>通过 RN 的 CLI 创建</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#react-native new-library --name &lt;yourLibraryName&gt;</span></span><br></pre></td></tr></table></figure>\n<p>命令执行后，可以在<code>./Libraries</code>下面找到创建的原生项目，<strong>这种方式只支持 iOS 项目</strong>。</p>\n<h3 id=\"通过-react-native-create-library-来创建\"><a href=\"#通过-react-native-create-library-来创建\" class=\"headerlink\" title=\"通过 react-native-create-library 来创建\"></a>通过 react-native-create-library 来创建</h3><ol>\n<li><p>安装<code>react-native-create-library</code>；</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g react-native-create-library</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>进入你要存放原生模块的目录（建议是 <code>Libraries</code>），执行下面的命令；</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">react-native-create-library &lt;yourLibraryName&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这种方式创建的项目中包含<code>iOS</code>、<code>Android</code>、<code>Windows</code>三个文件夹，对应三个平台。如果是开发跨平台的模块，建议使用这种方式。</p>\n<h2 id=\"RN-项目中引入原生模块项目\"><a href=\"#RN-项目中引入原生模块项目\" class=\"headerlink\" title=\"RN 项目中引入原生模块项目\"></a>RN 项目中引入原生模块项目</h2><p>这里只是开发 <code>iOS</code> 模块，所以直接使用方式一创建原生模块项目。<code>ExampleModule</code> 是 RN 项目，<code>MyFirstRNModule</code> 是原生模块。现在文件结构如下图：</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245383675028.jpg\" alt></p>\n<p>用 <code>xcode</code> 打开 <code>ExampleModule/ios</code> 下的 iOS 工程，添加 <code>MyFirstRNModule</code> 到<code>Libraries</code> 文件夹下，如下图：</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245390726193.jpg\" alt></p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245391049749.jpg\" alt></p>\n<p>链接 <code>MyFristRNModule</code> 到 <code>ExampleModule</code> 工程中：</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245394525224.jpg\" alt></p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245394784670.jpg\" alt></p>\n<p>至此，RN 项目就引入了原生模块项目。</p>\n<h2 id=\"编写原生模块代码\"><a href=\"#编写原生模块代码\" class=\"headerlink\" title=\"编写原生模块代码\"></a>编写原生模块代码</h2><p>这一部分按照 <a href=\"http://facebook.github.io/react-native/docs/native-modules-ios.html\" target=\"_blank\" rel=\"noopener\">RN 官方教程</a>来编写原生模块代码。</p>\n<p>在这里只做个简单的测试，看是否可以调用到这个模块。</p>\n<ol>\n<li><p>打开<code>MyFirstRNModule.m</code>文件，添加代码，然后使用模拟器运行；</p>\n<p> <img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245402331526.jpg\" alt></p>\n</li>\n<li><p>修改 RN 项目中的<code>App.js</code>；</p>\n<p> <img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245408646258.jpg\" alt></p>\n</li>\n<li><p>选中模拟器，<code>cmd+R</code> 刷新界面；</p>\n<p> <img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245409912857.jpg\" alt></p>\n</li>\n<li><p>点击 <code>test</code> 按键，注意观察 xcode 的调试窗口，这时会打印一条 <code>test</code> 信息出来，说明模块运行正确；</p>\n<p> <img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15245415527519.jpg\" alt></p>\n</li>\n</ol>\n<h2 id=\"发布上线\"><a href=\"#发布上线\" class=\"headerlink\" title=\"发布上线\"></a>发布上线</h2><p>编写好原生模块之后，就可以发布到 npm，这样其他人就可以下载使用。</p>\n<ol>\n<li>创建模块的 GitHub 仓库</li>\n<li><p>修改模块的入口文件</p>\n<p> 目录下已经有了 <code>MyFirstRNModule.ios.js</code> 可以作为入口文件，但是发布到 npm 上的包都是以 <code>index.js</code> 作为入口文件的，因此创建 <code>index.js</code>，将原生模块导出。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; NativeModules &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = NativeModules.MyFirstRNModule;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>发布到 npm</p>\n<p> 发布之前，需要先编辑 <code>package.json</code> 来配置原生模块的信息，如下：</p>\n <figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"my-first-rn-module\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"version\"</span>: <span class=\"string\">\"0.0.1\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"main\"</span>: <span class=\"string\">\"index.js\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"keywords\"</span>: <span class=\"string\">\"react-native\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"author\"</span>: <span class=\"string\">\"lg\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"license\"</span>: <span class=\"string\">\"MIT\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"repository\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"git\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"url\"</span>: <span class=\"string\">\"https://github.com/lg8294/MyFirstRNModule.git\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"homepage\"</span>: <span class=\"string\">\"https://github.com/lg8294/MyFirstRNModule\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"bugs\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"url\"</span>: <span class=\"string\">\"https://github.com/lg8294/MyFirstRNModule/issues\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 注：其中的 <code>name</code> 要采用 <code>kebab-case</code> 格式，否则发布的时候会报错。<br> 如果编写的原生模块依赖于其他的原生模块，需要在 package.json 添加依赖关系，这里由于没有相关依赖，所以不需要添加：</p>\n <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"dependencies\": &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 如果没有npm的账号，先注册一个账号，这个账号会被添加到npm本地的配置中，用来发布module用。</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm adduser</span><br><span class=\"line\">Username: your name</span><br><span class=\"line\">Password: your password</span><br><span class=\"line\">Email: yourmail@gmail.com</span><br></pre></td></tr></table></figure>\n<p> 发布：</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm publish</span><br></pre></td></tr></table></figure>\n<p> 有时候，有些文件没必要发布，例如 MyFirstRNModule.ios.js 和 MyFirstRNModule.android.js 文件，可以通过 .npmignore 忽略它。例如我这里 .npmignore 文件内容如下：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.git</span><br><span class=\"line\">.gitignore</span><br><span class=\"line\">MyFirstRNModule.ios.js</span><br><span class=\"line\">MyFirstRNModule.android.js</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加 README</p>\n<p> README 文件是非常重要的，如果没有 README 文件，别人看到这个组件，根本就不知道它是用来做什么的。所以，很有必要添加一个 README 文件，这个文件需要告诉别人这个原生组件是干什么的、如何安装、API、使用手册等等。</p>\n</li>\n</ol>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://chasecs.github.io/2017/08/09/react_native_packing_native_module_for_android_n_ios.html\" target=\"_blank\" rel=\"noopener\">React Native 原生模块库打包指南</a><br><a href=\"http://www.liuchungui.com/blog/2016/05/02/reactnativezhi-yuan-sheng-mo-kuai-kai-fa-bing-fa-bu-iospian/\" target=\"_blank\" rel=\"noopener\">ReactNative之原生模块开发并发布——iOS篇</a><br><a href=\"http://www.devio.org/2017/01/22/React-Native-iOS%E5%8E%9F%E7%94%9F%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-%E6%95%99%E7%A8%8B-%E5%BF%83%E5%BE%97/\" target=\"_blank\" rel=\"noopener\">如何创建React Native iOS原生模块</a></p>\n"},{"title":".dmg制作流程","date":"2018-07-27T06:55:21.000Z","_content":"# .dmg 制作流程\n\n1. 打开磁盘工具，新建空白磁盘，保存到桌面    \n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217911410964.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217911974362.jpg)\n\n2. 打开 tmp，放入需要打包的资源\n3. 设置图标。右键桌面上的 tmp 磁盘，点击`显示简介`，拖动图标到图示位置\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217915145273.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217916135987.jpg)\n\n4. 设置背景图片和图标大小。在 tmp 文件夹中点击右键，选择`查看显示选项`，拖动背景图片到图示位置\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217917390625.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217918498790.jpg)\n\n5. 打包成只读 dmp 文件。关闭 tmp 文件夹，推出 tmp，点击磁盘工具的转换按键，选中桌面的 tmp.dmg 文件，保存 \"tmp\"已转换.dmg 到桌面。至此就完成了 dmg 文件的制作。\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217920482902.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217920940345.jpg)\n\n\n放个效果图：\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217923175192.jpg)\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217922774462.jpg)","source":"_posts/dmg制作流程.md","raw":"---\ntitle: .dmg制作流程\ndate: 2018-07-27 14:55:21\ntags:\n---\n# .dmg 制作流程\n\n1. 打开磁盘工具，新建空白磁盘，保存到桌面    \n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217911410964.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217911974362.jpg)\n\n2. 打开 tmp，放入需要打包的资源\n3. 设置图标。右键桌面上的 tmp 磁盘，点击`显示简介`，拖动图标到图示位置\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217915145273.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217916135987.jpg)\n\n4. 设置背景图片和图标大小。在 tmp 文件夹中点击右键，选择`查看显示选项`，拖动背景图片到图示位置\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217917390625.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217918498790.jpg)\n\n5. 打包成只读 dmp 文件。关闭 tmp 文件夹，推出 tmp，点击磁盘工具的转换按键，选中桌面的 tmp.dmg 文件，保存 \"tmp\"已转换.dmg 到桌面。至此就完成了 dmg 文件的制作。\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217920482902.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217920940345.jpg)\n\n\n放个效果图：\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217923175192.jpg)\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217922774462.jpg)","slug":"dmg制作流程","published":1,"updated":"2018-07-27T07:04:35.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1k3jktg0001jz6ym58xamnl","content":"<h1 id=\"dmg-制作流程\"><a href=\"#dmg-制作流程\" class=\"headerlink\" title=\".dmg 制作流程\"></a>.dmg 制作流程</h1><ol>\n<li><p>打开磁盘工具，新建空白磁盘，保存到桌面<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217911410964.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217911974362.jpg\" alt></p>\n</li>\n<li><p>打开 tmp，放入需要打包的资源</p>\n</li>\n<li><p>设置图标。右键桌面上的 tmp 磁盘，点击<code>显示简介</code>，拖动图标到图示位置<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217915145273.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217916135987.jpg\" alt></p>\n</li>\n<li><p>设置背景图片和图标大小。在 tmp 文件夹中点击右键，选择<code>查看显示选项</code>，拖动背景图片到图示位置<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217917390625.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217918498790.jpg\" alt></p>\n</li>\n<li><p>打包成只读 dmp 文件。关闭 tmp 文件夹，推出 tmp，点击磁盘工具的转换按键，选中桌面的 tmp.dmg 文件，保存 “tmp”已转换.dmg 到桌面。至此就完成了 dmg 文件的制作。<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217920482902.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217920940345.jpg\" alt></p>\n</li>\n</ol>\n<p>放个效果图：<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217923175192.jpg\" alt></p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217922774462.jpg\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"dmg-制作流程\"><a href=\"#dmg-制作流程\" class=\"headerlink\" title=\".dmg 制作流程\"></a>.dmg 制作流程</h1><ol>\n<li><p>打开磁盘工具，新建空白磁盘，保存到桌面<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217911410964.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217911974362.jpg\" alt></p>\n</li>\n<li><p>打开 tmp，放入需要打包的资源</p>\n</li>\n<li><p>设置图标。右键桌面上的 tmp 磁盘，点击<code>显示简介</code>，拖动图标到图示位置<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217915145273.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217916135987.jpg\" alt></p>\n</li>\n<li><p>设置背景图片和图标大小。在 tmp 文件夹中点击右键，选择<code>查看显示选项</code>，拖动背景图片到图示位置<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217917390625.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217918498790.jpg\" alt></p>\n</li>\n<li><p>打包成只读 dmp 文件。关闭 tmp 文件夹，推出 tmp，点击磁盘工具的转换按键，选中桌面的 tmp.dmg 文件，保存 “tmp”已转换.dmg 到桌面。至此就完成了 dmg 文件的制作。<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217920482902.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217920940345.jpg\" alt></p>\n</li>\n</ol>\n<p>放个效果图：<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217923175192.jpg\" alt></p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15217922774462.jpg\" alt></p>\n"},{"title":".gitignore 语法规则","date":"2018-07-27T06:35:39.000Z","_content":"\n# .gitignore 语法规则\n\n> .gitignore 配置文件用于配置不需要加入版本管理的文件，配置好该文件可以为我们的版本管理带来很大的便利，以下是个人对于配置 .gitignore 的一些心得。\n\n### 配置语法：\n\n文件 .gitignore 的格式规范如下：\n\n- 所有空行或者以 ＃ 开头的行都会被 Git 忽略\n- 可以使用标准的 glob 模式匹配\n- 匹配模式可以以（/）开头防止递归\n- 匹配模式可以以（/）结尾指定目录\n- 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反\n\n> 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。\n> 星号（\\*）匹配零个或多个任意字符；\n> [abc]匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；\n> 问号（?）只匹配一个任意字符；\n> 如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。\n> 使用两个星号（\\*) 表示匹配任意中间目录，比如a/**/z 可以匹配 a/z, a/b/z 或 a/b/c/z等。\n\n### 示例：\n\n```\n# no .a files\n*.a\n\n# but do track lib.a, even though you're ignoring .a files above\n!lib.a\n\n# only ignore the TODO file in the current directory, not subdir/TODO\n/TODO\n\n# ignore all files in the build/ directory\nbuild/\n\n# ignore doc/notes.txt, but not doc/server/arch.txt\ndoc/*.txt\n\n# ignore all .pdf files in the doc/ directory\ndoc/**/*.pdf\n```\n\nGitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表，你可以在[https://github.com/github/gitignore](https://github.com/github/gitignore) 找到它.","source":"_posts/gitignore-语法规则.md","raw":"---\ntitle: .gitignore 语法规则\ndate: 2018-07-27 14:35:39\ntags:\n---\n\n# .gitignore 语法规则\n\n> .gitignore 配置文件用于配置不需要加入版本管理的文件，配置好该文件可以为我们的版本管理带来很大的便利，以下是个人对于配置 .gitignore 的一些心得。\n\n### 配置语法：\n\n文件 .gitignore 的格式规范如下：\n\n- 所有空行或者以 ＃ 开头的行都会被 Git 忽略\n- 可以使用标准的 glob 模式匹配\n- 匹配模式可以以（/）开头防止递归\n- 匹配模式可以以（/）结尾指定目录\n- 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反\n\n> 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。\n> 星号（\\*）匹配零个或多个任意字符；\n> [abc]匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；\n> 问号（?）只匹配一个任意字符；\n> 如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。\n> 使用两个星号（\\*) 表示匹配任意中间目录，比如a/**/z 可以匹配 a/z, a/b/z 或 a/b/c/z等。\n\n### 示例：\n\n```\n# no .a files\n*.a\n\n# but do track lib.a, even though you're ignoring .a files above\n!lib.a\n\n# only ignore the TODO file in the current directory, not subdir/TODO\n/TODO\n\n# ignore all files in the build/ directory\nbuild/\n\n# ignore doc/notes.txt, but not doc/server/arch.txt\ndoc/*.txt\n\n# ignore all .pdf files in the doc/ directory\ndoc/**/*.pdf\n```\n\nGitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表，你可以在[https://github.com/github/gitignore](https://github.com/github/gitignore) 找到它.","slug":"gitignore-语法规则","published":1,"updated":"2018-07-27T06:36:09.629Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1k3jkth0002jz6yfdxnpcq5","content":"<h1 id=\"gitignore-语法规则\"><a href=\"#gitignore-语法规则\" class=\"headerlink\" title=\".gitignore 语法规则\"></a>.gitignore 语法规则</h1><blockquote>\n<p>.gitignore 配置文件用于配置不需要加入版本管理的文件，配置好该文件可以为我们的版本管理带来很大的便利，以下是个人对于配置 .gitignore 的一些心得。</p>\n</blockquote>\n<h3 id=\"配置语法：\"><a href=\"#配置语法：\" class=\"headerlink\" title=\"配置语法：\"></a>配置语法：</h3><p>文件 .gitignore 的格式规范如下：</p>\n<ul>\n<li>所有空行或者以 ＃ 开头的行都会被 Git 忽略</li>\n<li>可以使用标准的 glob 模式匹配</li>\n<li>匹配模式可以以（/）开头防止递归</li>\n<li>匹配模式可以以（/）结尾指定目录</li>\n<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反</li>\n</ul>\n<blockquote>\n<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。<br>星号（*）匹配零个或多个任意字符；<br>[abc]匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；<br>问号（?）只匹配一个任意字符；<br>如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。<br>使用两个星号（*) 表示匹配任意中间目录，比如a/**/z 可以匹配 a/z, a/b/z 或 a/b/c/z等。</p>\n</blockquote>\n<h3 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># no .a files</span><br><span class=\"line\">*.a</span><br><span class=\"line\"></span><br><span class=\"line\"># but do track lib.a, even though you&apos;re ignoring .a files above</span><br><span class=\"line\">!lib.a</span><br><span class=\"line\"></span><br><span class=\"line\"># only ignore the TODO file in the current directory, not subdir/TODO</span><br><span class=\"line\">/TODO</span><br><span class=\"line\"></span><br><span class=\"line\"># ignore all files in the build/ directory</span><br><span class=\"line\">build/</span><br><span class=\"line\"></span><br><span class=\"line\"># ignore doc/notes.txt, but not doc/server/arch.txt</span><br><span class=\"line\">doc/*.txt</span><br><span class=\"line\"></span><br><span class=\"line\"># ignore all .pdf files in the doc/ directory</span><br><span class=\"line\">doc/**/*.pdf</span><br></pre></td></tr></table></figure>\n<p>GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表，你可以在<a href=\"https://github.com/github/gitignore\" target=\"_blank\" rel=\"noopener\">https://github.com/github/gitignore</a> 找到它.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"gitignore-语法规则\"><a href=\"#gitignore-语法规则\" class=\"headerlink\" title=\".gitignore 语法规则\"></a>.gitignore 语法规则</h1><blockquote>\n<p>.gitignore 配置文件用于配置不需要加入版本管理的文件，配置好该文件可以为我们的版本管理带来很大的便利，以下是个人对于配置 .gitignore 的一些心得。</p>\n</blockquote>\n<h3 id=\"配置语法：\"><a href=\"#配置语法：\" class=\"headerlink\" title=\"配置语法：\"></a>配置语法：</h3><p>文件 .gitignore 的格式规范如下：</p>\n<ul>\n<li>所有空行或者以 ＃ 开头的行都会被 Git 忽略</li>\n<li>可以使用标准的 glob 模式匹配</li>\n<li>匹配模式可以以（/）开头防止递归</li>\n<li>匹配模式可以以（/）结尾指定目录</li>\n<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反</li>\n</ul>\n<blockquote>\n<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。<br>星号（*）匹配零个或多个任意字符；<br>[abc]匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；<br>问号（?）只匹配一个任意字符；<br>如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。<br>使用两个星号（*) 表示匹配任意中间目录，比如a/**/z 可以匹配 a/z, a/b/z 或 a/b/c/z等。</p>\n</blockquote>\n<h3 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># no .a files</span><br><span class=\"line\">*.a</span><br><span class=\"line\"></span><br><span class=\"line\"># but do track lib.a, even though you&apos;re ignoring .a files above</span><br><span class=\"line\">!lib.a</span><br><span class=\"line\"></span><br><span class=\"line\"># only ignore the TODO file in the current directory, not subdir/TODO</span><br><span class=\"line\">/TODO</span><br><span class=\"line\"></span><br><span class=\"line\"># ignore all files in the build/ directory</span><br><span class=\"line\">build/</span><br><span class=\"line\"></span><br><span class=\"line\"># ignore doc/notes.txt, but not doc/server/arch.txt</span><br><span class=\"line\">doc/*.txt</span><br><span class=\"line\"></span><br><span class=\"line\"># ignore all .pdf files in the doc/ directory</span><br><span class=\"line\">doc/**/*.pdf</span><br></pre></td></tr></table></figure>\n<p>GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表，你可以在<a href=\"https://github.com/github/gitignore\" target=\"_blank\" rel=\"noopener\">https://github.com/github/gitignore</a> 找到它.</p>\n"},{"title":"iOS开发中关于库的版本号的研究","date":"2017-09-06T07:39:24.000Z","_content":"\n# iOS开发中关于库的版本号的研究\n在Xcode中创建了库工程之后，在库头文件中会有以下默认俩个字段：\n\n```OC\n//! Project version number for lib.\nFOUNDATION_EXPORT double libVersionNumber;\n\n//! Project version string for lib.\nFOUNDATION_EXPORT const unsigned char libVersionString[];\n```\n\n那么，这俩个字段具体怎么使用呢？\n从注释中可以看出，这俩个字段是代表项目的版本号。注意这里说的是项目是你建立的 Xcode 项目，而不是 Xcode 项目中的 Target。我们都知道每个Target都可以很方便的在 General 中修改 Version 和 Build，但是对以上俩个字段是没有影响的。因此你要指定以上俩个字段的值的正确方式是修改 Project->Build Settings->Current Project Version 这个键对应的值。\n\n# 自定义版本号\n## 添加自定义字段表示库的版本号\n如果你觉得通过过上面的方法修改不方便，那么我们可以添加一个自定义的字段来表示库的版本，例如\n\n```OC\nFOUNDATION_EXPORT double mylibVersionNumber;\n\nFOUNDATION_EXPORT NSString *const mylglibVersionString;\n```\n\n然后在库的实现文件中指定版本号\n\n```OC\ndouble mylglibVersionNumber = 1.1;\n\nNSString *const mylglibVersionString = @\"1.1.1\";\n```\n\n这个方法中建议使用字符串类型，数值类型由于小数点只能有一个，所以格式就会有限制。\n\n## 通过自定义方法获取版本号\n在我们开发库的过程中总是会有一个主功能类，那么我们就可以给这个类添加一个方法返回一个字符串形式的版本号，这个版本号表示这个功能的发布版本。通常由于一个库就是对一个功能的实现的打包，那么我们就可以用这个版本号作为这个库的版本号了。\n例如我的一个库主要实现 `Log` 功能，那么我的就可以这样来实现：\n\n\n```OC\n// Log.h\n#import <Foundation/Foundation.h>\n\n@interface LGLog : NSObject\n\n- (NSString *)log;\n\n+ (NSString *)version;\n\n@end\n\n// Log.m\n#import \"LGLog.h\"\n\nNSString *const kLogVersionString = @\"1.1.1\";\n\n@implementation Log\n\n- (NSString *)log {\n    NSLog(@\"log test\");\n    return @\"log test\";\n}\n\n+ (NSString *)version {\n    return kLogVersionString;\n}\n@end\n```\n\n这样我们就可以在使用的时候知道当前使用的库的版本号了。\n\n## 使用 Target 的版本号来作为库的版本号\n如果想要使用 Target 的版本号来作为库的版本号，那么只有采用自定义方法，然后在自定义方法中读取Info.plist信息。***这个方法只对动态库有效***。由于静态库在工程中导入后，最终打包出来后静态库和工程代码是合并到一个包里面的，因此读取到的 Info.plist 其实是 IPA 包的信息。\n\n```OC\n// Log.h\n#import <Foundation/Foundation.h>\n\n@interface LGLog : NSObject\n\n- (NSString *)log;\n\n+ (NSString *)version;\n\n@end\n\n// Log.m\n#import \"LGLog.h\"\n\n@implementation Log\n\n- (NSString *)log {\n    NSLog(@\"log test\");\n    return @\"log test\";\n}\n\n+ (NSString *)version {\n    NSDictionary *infoDic = [[NSBundle bundleForClass:self] infoDictionary];\n    NSString *version = [infoDic valueForKey:(__bridge NSString*)kCFBundleVersionKey];\n    return version;\n}\n@end\n```\n\n\n","source":"_posts/iOS开发中关于库的版本号的研究.md","raw":"---\ntitle: iOS开发中关于库的版本号的研究\ndate: 2017-09-06 15:39:24\ntags: iOS\n---\n\n# iOS开发中关于库的版本号的研究\n在Xcode中创建了库工程之后，在库头文件中会有以下默认俩个字段：\n\n```OC\n//! Project version number for lib.\nFOUNDATION_EXPORT double libVersionNumber;\n\n//! Project version string for lib.\nFOUNDATION_EXPORT const unsigned char libVersionString[];\n```\n\n那么，这俩个字段具体怎么使用呢？\n从注释中可以看出，这俩个字段是代表项目的版本号。注意这里说的是项目是你建立的 Xcode 项目，而不是 Xcode 项目中的 Target。我们都知道每个Target都可以很方便的在 General 中修改 Version 和 Build，但是对以上俩个字段是没有影响的。因此你要指定以上俩个字段的值的正确方式是修改 Project->Build Settings->Current Project Version 这个键对应的值。\n\n# 自定义版本号\n## 添加自定义字段表示库的版本号\n如果你觉得通过过上面的方法修改不方便，那么我们可以添加一个自定义的字段来表示库的版本，例如\n\n```OC\nFOUNDATION_EXPORT double mylibVersionNumber;\n\nFOUNDATION_EXPORT NSString *const mylglibVersionString;\n```\n\n然后在库的实现文件中指定版本号\n\n```OC\ndouble mylglibVersionNumber = 1.1;\n\nNSString *const mylglibVersionString = @\"1.1.1\";\n```\n\n这个方法中建议使用字符串类型，数值类型由于小数点只能有一个，所以格式就会有限制。\n\n## 通过自定义方法获取版本号\n在我们开发库的过程中总是会有一个主功能类，那么我们就可以给这个类添加一个方法返回一个字符串形式的版本号，这个版本号表示这个功能的发布版本。通常由于一个库就是对一个功能的实现的打包，那么我们就可以用这个版本号作为这个库的版本号了。\n例如我的一个库主要实现 `Log` 功能，那么我的就可以这样来实现：\n\n\n```OC\n// Log.h\n#import <Foundation/Foundation.h>\n\n@interface LGLog : NSObject\n\n- (NSString *)log;\n\n+ (NSString *)version;\n\n@end\n\n// Log.m\n#import \"LGLog.h\"\n\nNSString *const kLogVersionString = @\"1.1.1\";\n\n@implementation Log\n\n- (NSString *)log {\n    NSLog(@\"log test\");\n    return @\"log test\";\n}\n\n+ (NSString *)version {\n    return kLogVersionString;\n}\n@end\n```\n\n这样我们就可以在使用的时候知道当前使用的库的版本号了。\n\n## 使用 Target 的版本号来作为库的版本号\n如果想要使用 Target 的版本号来作为库的版本号，那么只有采用自定义方法，然后在自定义方法中读取Info.plist信息。***这个方法只对动态库有效***。由于静态库在工程中导入后，最终打包出来后静态库和工程代码是合并到一个包里面的，因此读取到的 Info.plist 其实是 IPA 包的信息。\n\n```OC\n// Log.h\n#import <Foundation/Foundation.h>\n\n@interface LGLog : NSObject\n\n- (NSString *)log;\n\n+ (NSString *)version;\n\n@end\n\n// Log.m\n#import \"LGLog.h\"\n\n@implementation Log\n\n- (NSString *)log {\n    NSLog(@\"log test\");\n    return @\"log test\";\n}\n\n+ (NSString *)version {\n    NSDictionary *infoDic = [[NSBundle bundleForClass:self] infoDictionary];\n    NSString *version = [infoDic valueForKey:(__bridge NSString*)kCFBundleVersionKey];\n    return version;\n}\n@end\n```\n\n\n","slug":"iOS开发中关于库的版本号的研究","published":1,"updated":"2018-04-24T08:09:12.675Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1k3jkti0003jz6yzssukpwa","content":"<h1 id=\"iOS开发中关于库的版本号的研究\"><a href=\"#iOS开发中关于库的版本号的研究\" class=\"headerlink\" title=\"iOS开发中关于库的版本号的研究\"></a>iOS开发中关于库的版本号的研究</h1><p>在Xcode中创建了库工程之后，在库头文件中会有以下默认俩个字段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//! Project version number for lib.</span><br><span class=\"line\">FOUNDATION_EXPORT double libVersionNumber;</span><br><span class=\"line\"></span><br><span class=\"line\">//! Project version string for lib.</span><br><span class=\"line\">FOUNDATION_EXPORT const unsigned char libVersionString[];</span><br></pre></td></tr></table></figure>\n<p>那么，这俩个字段具体怎么使用呢？<br>从注释中可以看出，这俩个字段是代表项目的版本号。注意这里说的是项目是你建立的 Xcode 项目，而不是 Xcode 项目中的 Target。我们都知道每个Target都可以很方便的在 General 中修改 Version 和 Build，但是对以上俩个字段是没有影响的。因此你要指定以上俩个字段的值的正确方式是修改 Project-&gt;Build Settings-&gt;Current Project Version 这个键对应的值。</p>\n<h1 id=\"自定义版本号\"><a href=\"#自定义版本号\" class=\"headerlink\" title=\"自定义版本号\"></a>自定义版本号</h1><h2 id=\"添加自定义字段表示库的版本号\"><a href=\"#添加自定义字段表示库的版本号\" class=\"headerlink\" title=\"添加自定义字段表示库的版本号\"></a>添加自定义字段表示库的版本号</h2><p>如果你觉得通过过上面的方法修改不方便，那么我们可以添加一个自定义的字段来表示库的版本，例如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FOUNDATION_EXPORT double mylibVersionNumber;</span><br><span class=\"line\"></span><br><span class=\"line\">FOUNDATION_EXPORT NSString *const mylglibVersionString;</span><br></pre></td></tr></table></figure>\n<p>然后在库的实现文件中指定版本号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double mylglibVersionNumber = 1.1;</span><br><span class=\"line\"></span><br><span class=\"line\">NSString *const mylglibVersionString = @&quot;1.1.1&quot;;</span><br></pre></td></tr></table></figure>\n<p>这个方法中建议使用字符串类型，数值类型由于小数点只能有一个，所以格式就会有限制。</p>\n<h2 id=\"通过自定义方法获取版本号\"><a href=\"#通过自定义方法获取版本号\" class=\"headerlink\" title=\"通过自定义方法获取版本号\"></a>通过自定义方法获取版本号</h2><p>在我们开发库的过程中总是会有一个主功能类，那么我们就可以给这个类添加一个方法返回一个字符串形式的版本号，这个版本号表示这个功能的发布版本。通常由于一个库就是对一个功能的实现的打包，那么我们就可以用这个版本号作为这个库的版本号了。<br>例如我的一个库主要实现 <code>Log</code> 功能，那么我的就可以这样来实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Log.h</span><br><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface LGLog : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSString *)log;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)version;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">// Log.m</span><br><span class=\"line\">#import &quot;LGLog.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">NSString *const kLogVersionString = @&quot;1.1.1&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Log</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSString *)log &#123;</span><br><span class=\"line\">    NSLog(@&quot;log test&quot;);</span><br><span class=\"line\">    return @&quot;log test&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)version &#123;</span><br><span class=\"line\">    return kLogVersionString;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>这样我们就可以在使用的时候知道当前使用的库的版本号了。</p>\n<h2 id=\"使用-Target-的版本号来作为库的版本号\"><a href=\"#使用-Target-的版本号来作为库的版本号\" class=\"headerlink\" title=\"使用 Target 的版本号来作为库的版本号\"></a>使用 Target 的版本号来作为库的版本号</h2><p>如果想要使用 Target 的版本号来作为库的版本号，那么只有采用自定义方法，然后在自定义方法中读取Info.plist信息。<strong><em>这个方法只对动态库有效</em></strong>。由于静态库在工程中导入后，最终打包出来后静态库和工程代码是合并到一个包里面的，因此读取到的 Info.plist 其实是 IPA 包的信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Log.h</span><br><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface LGLog : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSString *)log;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)version;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">// Log.m</span><br><span class=\"line\">#import &quot;LGLog.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Log</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSString *)log &#123;</span><br><span class=\"line\">    NSLog(@&quot;log test&quot;);</span><br><span class=\"line\">    return @&quot;log test&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)version &#123;</span><br><span class=\"line\">    NSDictionary *infoDic = [[NSBundle bundleForClass:self] infoDictionary];</span><br><span class=\"line\">    NSString *version = [infoDic valueForKey:(__bridge NSString*)kCFBundleVersionKey];</span><br><span class=\"line\">    return version;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"iOS开发中关于库的版本号的研究\"><a href=\"#iOS开发中关于库的版本号的研究\" class=\"headerlink\" title=\"iOS开发中关于库的版本号的研究\"></a>iOS开发中关于库的版本号的研究</h1><p>在Xcode中创建了库工程之后，在库头文件中会有以下默认俩个字段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//! Project version number for lib.</span><br><span class=\"line\">FOUNDATION_EXPORT double libVersionNumber;</span><br><span class=\"line\"></span><br><span class=\"line\">//! Project version string for lib.</span><br><span class=\"line\">FOUNDATION_EXPORT const unsigned char libVersionString[];</span><br></pre></td></tr></table></figure>\n<p>那么，这俩个字段具体怎么使用呢？<br>从注释中可以看出，这俩个字段是代表项目的版本号。注意这里说的是项目是你建立的 Xcode 项目，而不是 Xcode 项目中的 Target。我们都知道每个Target都可以很方便的在 General 中修改 Version 和 Build，但是对以上俩个字段是没有影响的。因此你要指定以上俩个字段的值的正确方式是修改 Project-&gt;Build Settings-&gt;Current Project Version 这个键对应的值。</p>\n<h1 id=\"自定义版本号\"><a href=\"#自定义版本号\" class=\"headerlink\" title=\"自定义版本号\"></a>自定义版本号</h1><h2 id=\"添加自定义字段表示库的版本号\"><a href=\"#添加自定义字段表示库的版本号\" class=\"headerlink\" title=\"添加自定义字段表示库的版本号\"></a>添加自定义字段表示库的版本号</h2><p>如果你觉得通过过上面的方法修改不方便，那么我们可以添加一个自定义的字段来表示库的版本，例如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FOUNDATION_EXPORT double mylibVersionNumber;</span><br><span class=\"line\"></span><br><span class=\"line\">FOUNDATION_EXPORT NSString *const mylglibVersionString;</span><br></pre></td></tr></table></figure>\n<p>然后在库的实现文件中指定版本号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double mylglibVersionNumber = 1.1;</span><br><span class=\"line\"></span><br><span class=\"line\">NSString *const mylglibVersionString = @&quot;1.1.1&quot;;</span><br></pre></td></tr></table></figure>\n<p>这个方法中建议使用字符串类型，数值类型由于小数点只能有一个，所以格式就会有限制。</p>\n<h2 id=\"通过自定义方法获取版本号\"><a href=\"#通过自定义方法获取版本号\" class=\"headerlink\" title=\"通过自定义方法获取版本号\"></a>通过自定义方法获取版本号</h2><p>在我们开发库的过程中总是会有一个主功能类，那么我们就可以给这个类添加一个方法返回一个字符串形式的版本号，这个版本号表示这个功能的发布版本。通常由于一个库就是对一个功能的实现的打包，那么我们就可以用这个版本号作为这个库的版本号了。<br>例如我的一个库主要实现 <code>Log</code> 功能，那么我的就可以这样来实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Log.h</span><br><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface LGLog : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSString *)log;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)version;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">// Log.m</span><br><span class=\"line\">#import &quot;LGLog.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">NSString *const kLogVersionString = @&quot;1.1.1&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Log</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSString *)log &#123;</span><br><span class=\"line\">    NSLog(@&quot;log test&quot;);</span><br><span class=\"line\">    return @&quot;log test&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)version &#123;</span><br><span class=\"line\">    return kLogVersionString;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>这样我们就可以在使用的时候知道当前使用的库的版本号了。</p>\n<h2 id=\"使用-Target-的版本号来作为库的版本号\"><a href=\"#使用-Target-的版本号来作为库的版本号\" class=\"headerlink\" title=\"使用 Target 的版本号来作为库的版本号\"></a>使用 Target 的版本号来作为库的版本号</h2><p>如果想要使用 Target 的版本号来作为库的版本号，那么只有采用自定义方法，然后在自定义方法中读取Info.plist信息。<strong><em>这个方法只对动态库有效</em></strong>。由于静态库在工程中导入后，最终打包出来后静态库和工程代码是合并到一个包里面的，因此读取到的 Info.plist 其实是 IPA 包的信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Log.h</span><br><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface LGLog : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSString *)log;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)version;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">// Log.m</span><br><span class=\"line\">#import &quot;LGLog.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Log</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSString *)log &#123;</span><br><span class=\"line\">    NSLog(@&quot;log test&quot;);</span><br><span class=\"line\">    return @&quot;log test&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)version &#123;</span><br><span class=\"line\">    NSDictionary *infoDic = [[NSBundle bundleForClass:self] infoDictionary];</span><br><span class=\"line\">    NSString *version = [infoDic valueForKey:(__bridge NSString*)kCFBundleVersionKey];</span><br><span class=\"line\">    return version;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n"},{"title":"myfirstpost","date":"2017-08-09T06:50:15.000Z","_content":"\n# 这是我的第一个文档\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)","source":"_posts/myfirstpost.md","raw":"---\ntitle: myfirstpost\ndate: 2017-08-09 14:50:15\ntags:\n---\n\n# 这是我的第一个文档\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)","slug":"myfirstpost","published":1,"updated":"2018-07-18T07:49:18.102Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1k3jktj0004jz6yc7l264te","content":"<h1 id=\"这是我的第一个文档\"><a href=\"#这是我的第一个文档\" class=\"headerlink\" title=\"这是我的第一个文档\"></a>这是我的第一个文档</h1><h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"这是我的第一个文档\"><a href=\"#这是我的第一个文档\" class=\"headerlink\" title=\"这是我的第一个文档\"></a>这是我的第一个文档</h1><h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"使用Jenkins构建iOS应用并上传蒲公英","date":"2018-07-27T06:36:45.000Z","_content":"\n# 使用 Jenkins 构建 iOS 应用并上传蒲公英\n\n## 安装\n\n在 Mac 上推荐使用 `brew` 来安装 `jenkins`:\n\n\n```sh\n$ brew install jenkins\n```\n\n可以选择 `lts` 版本：\n\n```sh\n$ brew install jenkins-lts\n```\n\n## 第一次启动\n\n通过 `brew` 安装成功后，在系统环境变量中会有 `jenkins`（或 `jenkins-lts`），执行命令就可以启动了：\n\n```sh\n$ jenkins\n```\n\n执行命令之后，不要关闭命令行窗口，否则这个服务就被关闭了。在命令行窗口中会有一条重要的信息，一条字符串信息，下面的步骤会用到。\n\n通过浏览器访问 `http://localhost:8080`，会出现如下界面：\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326539274571.png)\n\n这个界面要求输入管理员密码，这个密码就是之前命令行中的那个字符串，或者安装界面红色信息提示的，打开对应的文件，拷贝里面的字符串，填入这里的输入框中，点击 `Continue`。\n\n然后会显示自定义 Jenkins 的界面，其实就是安装 Plugins，Jenkins 的所有功能基本都是通过 Plugin 来实现的，所以这里现在第一项，`Install suggested plugins`：\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326546010952.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326546219760.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326546264089.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326546499338.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326546826845.jpg)\n\n到这里，输入用户名、密码、邮箱，创建第一个 Admin 用户。\n\n## 配置 iOS 构建项目\n\n构建 iOS 项目的方式有多种，下面是最长用的2种：\n\n1. 通过 Xcode Plugin;\n2. 通过 shell 脚本执行 fastlane；\n\n这里只说一下第一种方式。\n\n### 安装 `Xcode integration` 插件\n\n首先选择”系统管理“->”插件管理“->”可选插件“中搜索 `Xcode integration` 安装。\n安装完成之后，我们需要先去”系统管理“->”系统设置“里面配置一下 `Xcode Builder`：\n\n![QQ20180727-093711@2x](http://oe0m44pef.bkt.clouddn.com/2018-07-27-QQ20180727-093711@2x.png)\n\n在 `Apple Development Teams` 中配置你的开发者账号信息。你可以登录 [Apple 开发者中心](https://developer.apple.com/account)，然后选择 `Membership`，获取 `Team Name` 和 `Development Team ID`。\n\n在 `Keychains` 中配置你的钥匙串，通常这里配置成“登录”钥匙串：\n* `Keychain path` 通常是 `$(HOME)/Library/Keychains/login.keychains`\n* `Keychain password` 通常是你的登录密码\n* `Keychain Name` 你可已自定义\n\n**注意：这里配置的开发者账号的 development.cer 和 distribution.cer 要安装到安装 Jenkins 这台机器的 keychains 中，病区这个 keychinas 就是刚刚配置的”登录“钥匙串，这个要对应起来，否则在构建的时候会因为在钥匙串中找不到证书导致构建失败**\n\n### 安装 `Upload to pgyer` 插件\n\n在”系统管理“->”插件管理“->”可选插件“中搜索 `Upload to pgyer` 安装；\n\n### 创建 iOS 构建项目\n\n点击”新建任务“，输入一个任务名称，选择”构建一个自由风格的软件项目\"：\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326566521137.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326566641292.jpg)\n\n点击 `OK`，进入项目的配置界面：\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326608381287.jpg)\n\n所有的构建项目基本上都是由这几项构成的：\n\n- General（通用信息）\n- 源码管理\n- 构建触发器\n- 构建环境\n- 构建\n- 构建后操作\n\n在 `General` 中可以配置项目的基本信息，通常会配置”丢弃旧的构建“，如下图：\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326613438610.jpg)\n\n\n在”源码管理“中可以配置源码地址，通常使用 Git 来管理。\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326615267864.jpg)\n\n- `Repository URL`：源码仓库地址\n- `Credentials`：登录仓库的用户名和密码或者 SSH private key\n- `Branches to build`：用来构建的分支\n\n在”构建触发器“中可以配置如何触发这个构建过程。\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326617635924.jpg)\n\n通常选择”轮询 SCM“，如上图，代表每5分钟去检查一次仓库是否有更新，如果有更新，触发构建过程。\n\n在”构建环境“中可以配置构建工程的环境。\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326620001847.jpg)\n\n在”构建“中配置具体的构建过程。\n点击”添加构建步骤“->”Xcode“，添加 `Xcode` 构建过程。\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326621055206.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326621669132.jpg)\n\n在 `General build settings` 中配置具体的构建参数：\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326624614150.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326626076461.jpg)\n\n\n- `Development Team`：选择配置好的 Apple 开发者账号，如果留空，代表使用 iOS 工程中的配置\n- `Configuration`：Release 或者 Debug\n- `Scode Schema File`：用来打包 IPA 的 Schema\n\n在 `Code signing & OS X keychain options` 中配签名方式：\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326626704555.jpg)\n\n我这里配置的是自动签名，选择对应的 `keychain`，这个 `keychain` 是在之前”系统管理“中添加的；\n\n`Advanced Xcode build options` 和 `Versioning` 没有特殊需求，可以不管；\n\n\n在”构建后操作“中配置上传 IPA 到蒲公英的过程。\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326632311292.jpg)\n\n点击”增加构建后操作步骤“->”Upload to pgyer with apiV2“：\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326632178098.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326633020725.jpg)\n\n输入 `pyger api_key` 和 `file wildcard`。\n\n**注意：`file wildcard`（文件通配符）一定要能够匹配到构建出来的 IPA ，否则上传会失败。**\n\n最有一定要点击”保存“，完成项目的配置。\n\n## 构建\n\n在主面板上可以看到我们刚刚创建的项目：\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326636650942.jpg)\n\n点击最右侧的”构建按钮“，开始构建，这样可以立即检验我们之前的配置是否可用；\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326637535445.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326638019874.jpg)\n\n\n如果构建失败了，可以去查看Console Output可以查看log日志。\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326691235578.png)\n\n\n## 配置 Jenkins 作为后台进程\n\n执行命令：\n\n```sh\n$ brew services start jenkins\n```\n\n这样 Jenkins 就作为后台进程运行了，但是这样会有个问题，就是局域网内其他机器无法通过 ip 地址来访问，这时因为 jenkins 进程默认监听 ListenAddress 是 127.0.0.1。知道了原因，那么就可以通过修改 ListenAddress 来修复这个问题；\n\n打开 Jenkins 安装的文件夹 `/usr/local/Cellar/jenkins/`，打开对应版本下面的 `homebrew.mxcl.jenkins.plist` 文件，修改 `--httpListenAddress=0.0.0.0`，如下图：\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326698393440.jpg)\n\n然后执行命令：\n\n```sh\n$ brew services restart jenkins\n```\n\n这样，局域网内的其他机器就可以通过 ip 地址来访问 Jenkins 服务了。\n\n以上就是我关于Jenkins持续集成的一次实践经验。","source":"_posts/使用Jenkins构建iOS应用并上传蒲公英.md","raw":"---\ntitle: 使用Jenkins构建iOS应用并上传蒲公英\ndate: 2018-07-27 14:36:45\ntags:\n---\n\n# 使用 Jenkins 构建 iOS 应用并上传蒲公英\n\n## 安装\n\n在 Mac 上推荐使用 `brew` 来安装 `jenkins`:\n\n\n```sh\n$ brew install jenkins\n```\n\n可以选择 `lts` 版本：\n\n```sh\n$ brew install jenkins-lts\n```\n\n## 第一次启动\n\n通过 `brew` 安装成功后，在系统环境变量中会有 `jenkins`（或 `jenkins-lts`），执行命令就可以启动了：\n\n```sh\n$ jenkins\n```\n\n执行命令之后，不要关闭命令行窗口，否则这个服务就被关闭了。在命令行窗口中会有一条重要的信息，一条字符串信息，下面的步骤会用到。\n\n通过浏览器访问 `http://localhost:8080`，会出现如下界面：\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326539274571.png)\n\n这个界面要求输入管理员密码，这个密码就是之前命令行中的那个字符串，或者安装界面红色信息提示的，打开对应的文件，拷贝里面的字符串，填入这里的输入框中，点击 `Continue`。\n\n然后会显示自定义 Jenkins 的界面，其实就是安装 Plugins，Jenkins 的所有功能基本都是通过 Plugin 来实现的，所以这里现在第一项，`Install suggested plugins`：\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326546010952.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326546219760.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326546264089.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326546499338.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326546826845.jpg)\n\n到这里，输入用户名、密码、邮箱，创建第一个 Admin 用户。\n\n## 配置 iOS 构建项目\n\n构建 iOS 项目的方式有多种，下面是最长用的2种：\n\n1. 通过 Xcode Plugin;\n2. 通过 shell 脚本执行 fastlane；\n\n这里只说一下第一种方式。\n\n### 安装 `Xcode integration` 插件\n\n首先选择”系统管理“->”插件管理“->”可选插件“中搜索 `Xcode integration` 安装。\n安装完成之后，我们需要先去”系统管理“->”系统设置“里面配置一下 `Xcode Builder`：\n\n![QQ20180727-093711@2x](http://oe0m44pef.bkt.clouddn.com/2018-07-27-QQ20180727-093711@2x.png)\n\n在 `Apple Development Teams` 中配置你的开发者账号信息。你可以登录 [Apple 开发者中心](https://developer.apple.com/account)，然后选择 `Membership`，获取 `Team Name` 和 `Development Team ID`。\n\n在 `Keychains` 中配置你的钥匙串，通常这里配置成“登录”钥匙串：\n* `Keychain path` 通常是 `$(HOME)/Library/Keychains/login.keychains`\n* `Keychain password` 通常是你的登录密码\n* `Keychain Name` 你可已自定义\n\n**注意：这里配置的开发者账号的 development.cer 和 distribution.cer 要安装到安装 Jenkins 这台机器的 keychains 中，病区这个 keychinas 就是刚刚配置的”登录“钥匙串，这个要对应起来，否则在构建的时候会因为在钥匙串中找不到证书导致构建失败**\n\n### 安装 `Upload to pgyer` 插件\n\n在”系统管理“->”插件管理“->”可选插件“中搜索 `Upload to pgyer` 安装；\n\n### 创建 iOS 构建项目\n\n点击”新建任务“，输入一个任务名称，选择”构建一个自由风格的软件项目\"：\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326566521137.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326566641292.jpg)\n\n点击 `OK`，进入项目的配置界面：\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326608381287.jpg)\n\n所有的构建项目基本上都是由这几项构成的：\n\n- General（通用信息）\n- 源码管理\n- 构建触发器\n- 构建环境\n- 构建\n- 构建后操作\n\n在 `General` 中可以配置项目的基本信息，通常会配置”丢弃旧的构建“，如下图：\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326613438610.jpg)\n\n\n在”源码管理“中可以配置源码地址，通常使用 Git 来管理。\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326615267864.jpg)\n\n- `Repository URL`：源码仓库地址\n- `Credentials`：登录仓库的用户名和密码或者 SSH private key\n- `Branches to build`：用来构建的分支\n\n在”构建触发器“中可以配置如何触发这个构建过程。\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326617635924.jpg)\n\n通常选择”轮询 SCM“，如上图，代表每5分钟去检查一次仓库是否有更新，如果有更新，触发构建过程。\n\n在”构建环境“中可以配置构建工程的环境。\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326620001847.jpg)\n\n在”构建“中配置具体的构建过程。\n点击”添加构建步骤“->”Xcode“，添加 `Xcode` 构建过程。\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326621055206.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326621669132.jpg)\n\n在 `General build settings` 中配置具体的构建参数：\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326624614150.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326626076461.jpg)\n\n\n- `Development Team`：选择配置好的 Apple 开发者账号，如果留空，代表使用 iOS 工程中的配置\n- `Configuration`：Release 或者 Debug\n- `Scode Schema File`：用来打包 IPA 的 Schema\n\n在 `Code signing & OS X keychain options` 中配签名方式：\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326626704555.jpg)\n\n我这里配置的是自动签名，选择对应的 `keychain`，这个 `keychain` 是在之前”系统管理“中添加的；\n\n`Advanced Xcode build options` 和 `Versioning` 没有特殊需求，可以不管；\n\n\n在”构建后操作“中配置上传 IPA 到蒲公英的过程。\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326632311292.jpg)\n\n点击”增加构建后操作步骤“->”Upload to pgyer with apiV2“：\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326632178098.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326633020725.jpg)\n\n输入 `pyger api_key` 和 `file wildcard`。\n\n**注意：`file wildcard`（文件通配符）一定要能够匹配到构建出来的 IPA ，否则上传会失败。**\n\n最有一定要点击”保存“，完成项目的配置。\n\n## 构建\n\n在主面板上可以看到我们刚刚创建的项目：\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326636650942.jpg)\n\n点击最右侧的”构建按钮“，开始构建，这样可以立即检验我们之前的配置是否可用；\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326637535445.jpg)\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326638019874.jpg)\n\n\n如果构建失败了，可以去查看Console Output可以查看log日志。\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326691235578.png)\n\n\n## 配置 Jenkins 作为后台进程\n\n执行命令：\n\n```sh\n$ brew services start jenkins\n```\n\n这样 Jenkins 就作为后台进程运行了，但是这样会有个问题，就是局域网内其他机器无法通过 ip 地址来访问，这时因为 jenkins 进程默认监听 ListenAddress 是 127.0.0.1。知道了原因，那么就可以通过修改 ListenAddress 来修复这个问题；\n\n打开 Jenkins 安装的文件夹 `/usr/local/Cellar/jenkins/`，打开对应版本下面的 `homebrew.mxcl.jenkins.plist` 文件，修改 `--httpListenAddress=0.0.0.0`，如下图：\n\n![](http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326698393440.jpg)\n\n然后执行命令：\n\n```sh\n$ brew services restart jenkins\n```\n\n这样，局域网内的其他机器就可以通过 ip 地址来访问 Jenkins 服务了。\n\n以上就是我关于Jenkins持续集成的一次实践经验。","slug":"使用Jenkins构建iOS应用并上传蒲公英","published":1,"updated":"2018-07-27T07:01:35.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1k3jktk0005jz6yklmoyp4o","content":"<h1 id=\"使用-Jenkins-构建-iOS-应用并上传蒲公英\"><a href=\"#使用-Jenkins-构建-iOS-应用并上传蒲公英\" class=\"headerlink\" title=\"使用 Jenkins 构建 iOS 应用并上传蒲公英\"></a>使用 Jenkins 构建 iOS 应用并上传蒲公英</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>在 Mac 上推荐使用 <code>brew</code> 来安装 <code>jenkins</code>:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install jenkins</span><br></pre></td></tr></table></figure>\n<p>可以选择 <code>lts</code> 版本：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install jenkins-lts</span><br></pre></td></tr></table></figure>\n<h2 id=\"第一次启动\"><a href=\"#第一次启动\" class=\"headerlink\" title=\"第一次启动\"></a>第一次启动</h2><p>通过 <code>brew</code> 安装成功后，在系统环境变量中会有 <code>jenkins</code>（或 <code>jenkins-lts</code>），执行命令就可以启动了：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jenkins</span><br></pre></td></tr></table></figure>\n<p>执行命令之后，不要关闭命令行窗口，否则这个服务就被关闭了。在命令行窗口中会有一条重要的信息，一条字符串信息，下面的步骤会用到。</p>\n<p>通过浏览器访问 <code>http://localhost:8080</code>，会出现如下界面：<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326539274571.png\" alt></p>\n<p>这个界面要求输入管理员密码，这个密码就是之前命令行中的那个字符串，或者安装界面红色信息提示的，打开对应的文件，拷贝里面的字符串，填入这里的输入框中，点击 <code>Continue</code>。</p>\n<p>然后会显示自定义 Jenkins 的界面，其实就是安装 Plugins，Jenkins 的所有功能基本都是通过 Plugin 来实现的，所以这里现在第一项，<code>Install suggested plugins</code>：</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326546010952.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326546219760.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326546264089.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326546499338.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326546826845.jpg\" alt></p>\n<p>到这里，输入用户名、密码、邮箱，创建第一个 Admin 用户。</p>\n<h2 id=\"配置-iOS-构建项目\"><a href=\"#配置-iOS-构建项目\" class=\"headerlink\" title=\"配置 iOS 构建项目\"></a>配置 iOS 构建项目</h2><p>构建 iOS 项目的方式有多种，下面是最长用的2种：</p>\n<ol>\n<li>通过 Xcode Plugin;</li>\n<li>通过 shell 脚本执行 fastlane；</li>\n</ol>\n<p>这里只说一下第一种方式。</p>\n<h3 id=\"安装-Xcode-integration-插件\"><a href=\"#安装-Xcode-integration-插件\" class=\"headerlink\" title=\"安装 Xcode integration 插件\"></a>安装 <code>Xcode integration</code> 插件</h3><p>首先选择”系统管理“-&gt;”插件管理“-&gt;”可选插件“中搜索 <code>Xcode integration</code> 安装。<br>安装完成之后，我们需要先去”系统管理“-&gt;”系统设置“里面配置一下 <code>Xcode Builder</code>：</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-QQ20180727-093711@2x.png\" alt=\"QQ20180727-093711@2x\"></p>\n<p>在 <code>Apple Development Teams</code> 中配置你的开发者账号信息。你可以登录 <a href=\"https://developer.apple.com/account\" target=\"_blank\" rel=\"noopener\">Apple 开发者中心</a>，然后选择 <code>Membership</code>，获取 <code>Team Name</code> 和 <code>Development Team ID</code>。</p>\n<p>在 <code>Keychains</code> 中配置你的钥匙串，通常这里配置成“登录”钥匙串：</p>\n<ul>\n<li><code>Keychain path</code> 通常是 <code>$(HOME)/Library/Keychains/login.keychains</code></li>\n<li><code>Keychain password</code> 通常是你的登录密码</li>\n<li><code>Keychain Name</code> 你可已自定义</li>\n</ul>\n<p><strong>注意：这里配置的开发者账号的 development.cer 和 distribution.cer 要安装到安装 Jenkins 这台机器的 keychains 中，病区这个 keychinas 就是刚刚配置的”登录“钥匙串，这个要对应起来，否则在构建的时候会因为在钥匙串中找不到证书导致构建失败</strong></p>\n<h3 id=\"安装-Upload-to-pgyer-插件\"><a href=\"#安装-Upload-to-pgyer-插件\" class=\"headerlink\" title=\"安装 Upload to pgyer 插件\"></a>安装 <code>Upload to pgyer</code> 插件</h3><p>在”系统管理“-&gt;”插件管理“-&gt;”可选插件“中搜索 <code>Upload to pgyer</code> 安装；</p>\n<h3 id=\"创建-iOS-构建项目\"><a href=\"#创建-iOS-构建项目\" class=\"headerlink\" title=\"创建 iOS 构建项目\"></a>创建 iOS 构建项目</h3><p>点击”新建任务“，输入一个任务名称，选择”构建一个自由风格的软件项目”：<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326566521137.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326566641292.jpg\" alt></p>\n<p>点击 <code>OK</code>，进入项目的配置界面：<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326608381287.jpg\" alt></p>\n<p>所有的构建项目基本上都是由这几项构成的：</p>\n<ul>\n<li>General（通用信息）</li>\n<li>源码管理</li>\n<li>构建触发器</li>\n<li>构建环境</li>\n<li>构建</li>\n<li>构建后操作</li>\n</ul>\n<p>在 <code>General</code> 中可以配置项目的基本信息，通常会配置”丢弃旧的构建“，如下图：<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326613438610.jpg\" alt></p>\n<p>在”源码管理“中可以配置源码地址，通常使用 Git 来管理。</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326615267864.jpg\" alt></p>\n<ul>\n<li><code>Repository URL</code>：源码仓库地址</li>\n<li><code>Credentials</code>：登录仓库的用户名和密码或者 SSH private key</li>\n<li><code>Branches to build</code>：用来构建的分支</li>\n</ul>\n<p>在”构建触发器“中可以配置如何触发这个构建过程。<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326617635924.jpg\" alt></p>\n<p>通常选择”轮询 SCM“，如上图，代表每5分钟去检查一次仓库是否有更新，如果有更新，触发构建过程。</p>\n<p>在”构建环境“中可以配置构建工程的环境。<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326620001847.jpg\" alt></p>\n<p>在”构建“中配置具体的构建过程。<br>点击”添加构建步骤“-&gt;”Xcode“，添加 <code>Xcode</code> 构建过程。<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326621055206.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326621669132.jpg\" alt></p>\n<p>在 <code>General build settings</code> 中配置具体的构建参数：</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326624614150.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326626076461.jpg\" alt></p>\n<ul>\n<li><code>Development Team</code>：选择配置好的 Apple 开发者账号，如果留空，代表使用 iOS 工程中的配置</li>\n<li><code>Configuration</code>：Release 或者 Debug</li>\n<li><code>Scode Schema File</code>：用来打包 IPA 的 Schema</li>\n</ul>\n<p>在 <code>Code signing &amp; OS X keychain options</code> 中配签名方式：</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326626704555.jpg\" alt></p>\n<p>我这里配置的是自动签名，选择对应的 <code>keychain</code>，这个 <code>keychain</code> 是在之前”系统管理“中添加的；</p>\n<p><code>Advanced Xcode build options</code> 和 <code>Versioning</code> 没有特殊需求，可以不管；</p>\n<p>在”构建后操作“中配置上传 IPA 到蒲公英的过程。</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326632311292.jpg\" alt></p>\n<p>点击”增加构建后操作步骤“-&gt;”Upload to pgyer with apiV2“：</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326632178098.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326633020725.jpg\" alt></p>\n<p>输入 <code>pyger api_key</code> 和 <code>file wildcard</code>。</p>\n<p><strong>注意：<code>file wildcard</code>（文件通配符）一定要能够匹配到构建出来的 IPA ，否则上传会失败。</strong></p>\n<p>最有一定要点击”保存“，完成项目的配置。</p>\n<h2 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h2><p>在主面板上可以看到我们刚刚创建的项目：</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326636650942.jpg\" alt></p>\n<p>点击最右侧的”构建按钮“，开始构建，这样可以立即检验我们之前的配置是否可用；</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326637535445.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326638019874.jpg\" alt></p>\n<p>如果构建失败了，可以去查看Console Output可以查看log日志。</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326691235578.png\" alt></p>\n<h2 id=\"配置-Jenkins-作为后台进程\"><a href=\"#配置-Jenkins-作为后台进程\" class=\"headerlink\" title=\"配置 Jenkins 作为后台进程\"></a>配置 Jenkins 作为后台进程</h2><p>执行命令：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew services start jenkins</span><br></pre></td></tr></table></figure>\n<p>这样 Jenkins 就作为后台进程运行了，但是这样会有个问题，就是局域网内其他机器无法通过 ip 地址来访问，这时因为 jenkins 进程默认监听 ListenAddress 是 127.0.0.1。知道了原因，那么就可以通过修改 ListenAddress 来修复这个问题；</p>\n<p>打开 Jenkins 安装的文件夹 <code>/usr/local/Cellar/jenkins/</code>，打开对应版本下面的 <code>homebrew.mxcl.jenkins.plist</code> 文件，修改 <code>--httpListenAddress=0.0.0.0</code>，如下图：</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326698393440.jpg\" alt></p>\n<p>然后执行命令：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew services restart jenkins</span><br></pre></td></tr></table></figure>\n<p>这样，局域网内的其他机器就可以通过 ip 地址来访问 Jenkins 服务了。</p>\n<p>以上就是我关于Jenkins持续集成的一次实践经验。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用-Jenkins-构建-iOS-应用并上传蒲公英\"><a href=\"#使用-Jenkins-构建-iOS-应用并上传蒲公英\" class=\"headerlink\" title=\"使用 Jenkins 构建 iOS 应用并上传蒲公英\"></a>使用 Jenkins 构建 iOS 应用并上传蒲公英</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>在 Mac 上推荐使用 <code>brew</code> 来安装 <code>jenkins</code>:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install jenkins</span><br></pre></td></tr></table></figure>\n<p>可以选择 <code>lts</code> 版本：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install jenkins-lts</span><br></pre></td></tr></table></figure>\n<h2 id=\"第一次启动\"><a href=\"#第一次启动\" class=\"headerlink\" title=\"第一次启动\"></a>第一次启动</h2><p>通过 <code>brew</code> 安装成功后，在系统环境变量中会有 <code>jenkins</code>（或 <code>jenkins-lts</code>），执行命令就可以启动了：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jenkins</span><br></pre></td></tr></table></figure>\n<p>执行命令之后，不要关闭命令行窗口，否则这个服务就被关闭了。在命令行窗口中会有一条重要的信息，一条字符串信息，下面的步骤会用到。</p>\n<p>通过浏览器访问 <code>http://localhost:8080</code>，会出现如下界面：<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326539274571.png\" alt></p>\n<p>这个界面要求输入管理员密码，这个密码就是之前命令行中的那个字符串，或者安装界面红色信息提示的，打开对应的文件，拷贝里面的字符串，填入这里的输入框中，点击 <code>Continue</code>。</p>\n<p>然后会显示自定义 Jenkins 的界面，其实就是安装 Plugins，Jenkins 的所有功能基本都是通过 Plugin 来实现的，所以这里现在第一项，<code>Install suggested plugins</code>：</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326546010952.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326546219760.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326546264089.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326546499338.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326546826845.jpg\" alt></p>\n<p>到这里，输入用户名、密码、邮箱，创建第一个 Admin 用户。</p>\n<h2 id=\"配置-iOS-构建项目\"><a href=\"#配置-iOS-构建项目\" class=\"headerlink\" title=\"配置 iOS 构建项目\"></a>配置 iOS 构建项目</h2><p>构建 iOS 项目的方式有多种，下面是最长用的2种：</p>\n<ol>\n<li>通过 Xcode Plugin;</li>\n<li>通过 shell 脚本执行 fastlane；</li>\n</ol>\n<p>这里只说一下第一种方式。</p>\n<h3 id=\"安装-Xcode-integration-插件\"><a href=\"#安装-Xcode-integration-插件\" class=\"headerlink\" title=\"安装 Xcode integration 插件\"></a>安装 <code>Xcode integration</code> 插件</h3><p>首先选择”系统管理“-&gt;”插件管理“-&gt;”可选插件“中搜索 <code>Xcode integration</code> 安装。<br>安装完成之后，我们需要先去”系统管理“-&gt;”系统设置“里面配置一下 <code>Xcode Builder</code>：</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-QQ20180727-093711@2x.png\" alt=\"QQ20180727-093711@2x\"></p>\n<p>在 <code>Apple Development Teams</code> 中配置你的开发者账号信息。你可以登录 <a href=\"https://developer.apple.com/account\" target=\"_blank\" rel=\"noopener\">Apple 开发者中心</a>，然后选择 <code>Membership</code>，获取 <code>Team Name</code> 和 <code>Development Team ID</code>。</p>\n<p>在 <code>Keychains</code> 中配置你的钥匙串，通常这里配置成“登录”钥匙串：</p>\n<ul>\n<li><code>Keychain path</code> 通常是 <code>$(HOME)/Library/Keychains/login.keychains</code></li>\n<li><code>Keychain password</code> 通常是你的登录密码</li>\n<li><code>Keychain Name</code> 你可已自定义</li>\n</ul>\n<p><strong>注意：这里配置的开发者账号的 development.cer 和 distribution.cer 要安装到安装 Jenkins 这台机器的 keychains 中，病区这个 keychinas 就是刚刚配置的”登录“钥匙串，这个要对应起来，否则在构建的时候会因为在钥匙串中找不到证书导致构建失败</strong></p>\n<h3 id=\"安装-Upload-to-pgyer-插件\"><a href=\"#安装-Upload-to-pgyer-插件\" class=\"headerlink\" title=\"安装 Upload to pgyer 插件\"></a>安装 <code>Upload to pgyer</code> 插件</h3><p>在”系统管理“-&gt;”插件管理“-&gt;”可选插件“中搜索 <code>Upload to pgyer</code> 安装；</p>\n<h3 id=\"创建-iOS-构建项目\"><a href=\"#创建-iOS-构建项目\" class=\"headerlink\" title=\"创建 iOS 构建项目\"></a>创建 iOS 构建项目</h3><p>点击”新建任务“，输入一个任务名称，选择”构建一个自由风格的软件项目”：<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326566521137.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326566641292.jpg\" alt></p>\n<p>点击 <code>OK</code>，进入项目的配置界面：<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326608381287.jpg\" alt></p>\n<p>所有的构建项目基本上都是由这几项构成的：</p>\n<ul>\n<li>General（通用信息）</li>\n<li>源码管理</li>\n<li>构建触发器</li>\n<li>构建环境</li>\n<li>构建</li>\n<li>构建后操作</li>\n</ul>\n<p>在 <code>General</code> 中可以配置项目的基本信息，通常会配置”丢弃旧的构建“，如下图：<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326613438610.jpg\" alt></p>\n<p>在”源码管理“中可以配置源码地址，通常使用 Git 来管理。</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326615267864.jpg\" alt></p>\n<ul>\n<li><code>Repository URL</code>：源码仓库地址</li>\n<li><code>Credentials</code>：登录仓库的用户名和密码或者 SSH private key</li>\n<li><code>Branches to build</code>：用来构建的分支</li>\n</ul>\n<p>在”构建触发器“中可以配置如何触发这个构建过程。<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326617635924.jpg\" alt></p>\n<p>通常选择”轮询 SCM“，如上图，代表每5分钟去检查一次仓库是否有更新，如果有更新，触发构建过程。</p>\n<p>在”构建环境“中可以配置构建工程的环境。<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326620001847.jpg\" alt></p>\n<p>在”构建“中配置具体的构建过程。<br>点击”添加构建步骤“-&gt;”Xcode“，添加 <code>Xcode</code> 构建过程。<br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326621055206.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326621669132.jpg\" alt></p>\n<p>在 <code>General build settings</code> 中配置具体的构建参数：</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326624614150.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326626076461.jpg\" alt></p>\n<ul>\n<li><code>Development Team</code>：选择配置好的 Apple 开发者账号，如果留空，代表使用 iOS 工程中的配置</li>\n<li><code>Configuration</code>：Release 或者 Debug</li>\n<li><code>Scode Schema File</code>：用来打包 IPA 的 Schema</li>\n</ul>\n<p>在 <code>Code signing &amp; OS X keychain options</code> 中配签名方式：</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326626704555.jpg\" alt></p>\n<p>我这里配置的是自动签名，选择对应的 <code>keychain</code>，这个 <code>keychain</code> 是在之前”系统管理“中添加的；</p>\n<p><code>Advanced Xcode build options</code> 和 <code>Versioning</code> 没有特殊需求，可以不管；</p>\n<p>在”构建后操作“中配置上传 IPA 到蒲公英的过程。</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326632311292.jpg\" alt></p>\n<p>点击”增加构建后操作步骤“-&gt;”Upload to pgyer with apiV2“：</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326632178098.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326633020725.jpg\" alt></p>\n<p>输入 <code>pyger api_key</code> 和 <code>file wildcard</code>。</p>\n<p><strong>注意：<code>file wildcard</code>（文件通配符）一定要能够匹配到构建出来的 IPA ，否则上传会失败。</strong></p>\n<p>最有一定要点击”保存“，完成项目的配置。</p>\n<h2 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h2><p>在主面板上可以看到我们刚刚创建的项目：</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326636650942.jpg\" alt></p>\n<p>点击最右侧的”构建按钮“，开始构建，这样可以立即检验我们之前的配置是否可用；</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326637535445.jpg\" alt><br><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326638019874.jpg\" alt></p>\n<p>如果构建失败了，可以去查看Console Output可以查看log日志。</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326691235578.png\" alt></p>\n<h2 id=\"配置-Jenkins-作为后台进程\"><a href=\"#配置-Jenkins-作为后台进程\" class=\"headerlink\" title=\"配置 Jenkins 作为后台进程\"></a>配置 Jenkins 作为后台进程</h2><p>执行命令：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew services start jenkins</span><br></pre></td></tr></table></figure>\n<p>这样 Jenkins 就作为后台进程运行了，但是这样会有个问题，就是局域网内其他机器无法通过 ip 地址来访问，这时因为 jenkins 进程默认监听 ListenAddress 是 127.0.0.1。知道了原因，那么就可以通过修改 ListenAddress 来修复这个问题；</p>\n<p>打开 Jenkins 安装的文件夹 <code>/usr/local/Cellar/jenkins/</code>，打开对应版本下面的 <code>homebrew.mxcl.jenkins.plist</code> 文件，修改 <code>--httpListenAddress=0.0.0.0</code>，如下图：</p>\n<p><img src=\"http://oe0m44pef.bkt.clouddn.com/2018-07-27-15326698393440.jpg\" alt></p>\n<p>然后执行命令：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew services restart jenkins</span><br></pre></td></tr></table></figure>\n<p>这样，局域网内的其他机器就可以通过 ip 地址来访问 Jenkins 服务了。</p>\n<p>以上就是我关于Jenkins持续集成的一次实践经验。</p>\n"},{"title":"常见证书格式及相互转换","date":"2017-08-16T09:50:27.000Z","_content":"\n\n# 常见证书格式及相互转换\n\nPKCS 全称是 Public-Key Cryptography Standards ，是由 RSA 实验室与其它安全系统开发商为促进公钥密码的发展而制订的一系列标准，PKCS 目前共发布过 15 个标准。 \n\n常用的有：\nPKCS#7 Cryptographic Message Syntax Standard\nPKCS#10 Certification Request Standard\nPKCS#12 Personal Information Exchange Syntax Standard\n\n\nX.509是常见通用的证书格式。所有的证书都符合为Public Key Infrastructure (PKI) 制定的 ITU-T X509 国际标准。\n\n\nPKCS#7 常用的后缀是： .P7B .P7C .SPC\nPKCS#12 常用的后缀有： .P12 .PFX\nX.509 DER 编码(ASCII)的后缀是： .DER .CER .CRT\nX.509 PAM 编码(Base64)的后缀是： .PEM .CER .CRT\n.cer/.crt是用于存放证书，它是2进制形式存放的，不含私钥。\n.pem跟crt/cer的区别是它以Ascii来表示。\npfx/p12用于存放个人证书/私钥，他通常包含保护密码，2进制方式\np10是证书请求\np7r是CA对证书请求的回复，只用于导入\np7b以树状展示证书链(certificate chain)，同时也支持单个证书，不含私钥。\n\n\nder,cer文件一般是二进制格式的，只放证书，不含私钥\ncrt文件可能是二进制的，也可能是文本格式的，应该以文本格式居多，功能同der/cer\npem文件一般是文本格式的，可以放证书或者私钥，或者两者都有\npem如果只含私钥的话，一般用.key扩展名，而且可以有密码保护\npfx,p12文件是二进制格式，同时含私钥和证书，通常有保护密码\n\n\n\n1. 怎么判断是文本格式还是二进制？\n\n    用记事本打开，如果是规则的数字字母，如\n\n    ```\n    —–BEGIN CERTIFICATE—–\n    MIIE9jCCA96gAwIBAgIQVXD9d9wgivhJM//a3VIcDjANBgkqhkiG9w0BAQUFADBy\n    —–END CERTIFICATE—–\n    ```\n\n    就是文本的。\n\n    上面的`—–BEGIN CERTIFICATE—–`，说明这是一个证书；\n    如果是`—–BEGIN RSA PRIVATE KEY—–`，说明这是一个私钥，文本格式的私钥，也可能有密码保护；\n\n2. 文本格式怎么变成二进制？\n\n    从程序角度来说，去掉前后的—-行，剩下的去掉回车，用base64解码，就得到二进制了,不过一般都用命令行openssl完成这个工作；\n\n## 一 用openssl创建CA证书的RSA密钥(PEM格式)：\n```\nopenssl genrsa -des3 -out ca.key 1024\n```\n\n## 二 用openssl创建CA证书(PEM格式,假如有效期为一年)：\n```\nopenssl req -new -x509 -days 365 -key ca.key -out ca.crt -config openssl.cnf\n//openssl是可以生成DER格式的CA证书的，最好用IE将PEM格式的CA证书转换成DER格式的CA证书。\n```\n\n## 三 x509到pfx\n```\npkcs12 -export –in keys/client1.crt -inkey keys/client1.key -out keys/client1.pfx\n```\n\n## 四 PEM格式的ca.key转换为Microsoft可以识别的pvk格式。\n```\npvk -in ca.key -out ca.pvk -nocrypt -topvk\n```\n\n## 五 PKCS#12 到 PEM 的转换\n```\nopenssl pkcs12 -nocerts -nodes -in cert.p12 -out private.pem\n//验证 openssl pkcs12 -clcerts -nokeys -in cert.p12 -out cert.pem\n```\n\n## 六 从 PFX 格式文件中提取私钥格式文件 (.key)\n```\nopenssl pkcs12 -in mycert.pfx -nocerts -nodes -out mycert.key\n```\n\n## 七 转换 pem 到到 spc\n```\nopenssl crl2pkcs7 -nocrl -certfile venus.pem -outform DER -out venus.spc\n//用 -outform -inform 指定 DER 还是 PAM 格式。例如：\nopenssl x509 -in Cert.pem -inform PEM -out cert.der -outform DER\n```\n\n## 八 PEM 到 PKCS#12 的转换\n```\nopenssl pkcs12 -export -in Cert.pem -out Cert.p12 -inkey key.pem\n```\n\n## 九 从用户证书 server.crt提取出公钥文件\n```\nopenssl x509 -outform PEM -in server/server.crt -pubkey -out server/server.pubkey\n\n<!--\n-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDYhJizzt4+zhLMTSjDk0rd6MlK\nxBYKIp972+Wc9KSpOs5LGQ+2802mlr6dSDWJJhJShArqOIKgxNE7ZBZYlGeDo4l6\nDm4DyVFpu62fObgk6vmU8T7nvF8Uo7sQdpfqgUjofGFgUDjB3fYgKUTp+kOj6RMh\nR3uttrZmOraF/rEUkQIDAQAB\n-----END PUBLIC KEY-----\n-->\n```\n\n可以显示公钥信息，手动将其中内容复制到一个文件中做公钥测试成功，但是此命令输出的文件内容不是公钥信息，内容如下：\n```\n-----BEGIN CERTIFICATE-----\nMIICpTCCAg6gAwIBAgIBATANBgkqhkiG9w0BAQUFADBFMQswCQYDVQQGEwJjbjEQ\nMA4GA1UECBMHYmVpamluZzEMMAoGA1UEChMDYW9lMRYwFAYDVQQDEw13d3cuenlu\nZXQubXRuMB4XDTEzMDYwMjAxMjIxNloXDTE0MDYwMjAxMjIxNlowbzELMAkGA1UE\nBhMCY24xEDAOBgNVBAgMB2JlaWppbmcxDDAKBgNVBAoMA0FPRTEPMA0GA1UEAwwG\nd2l6YXJkMQwwCgYDVQQLDANjb3AxITAfBgkqhkiG9w0BCQEWEnd6aGgxOTg4QGdt\nYWlsLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA2ISYs87ePs4SzE0o\nw5NK3ejJSsQWCiKfe9vlnPSkqTrOSxkPtvNNppa+nUg1iSYSUoQK6jiCoMTRO2QW\nWJRng6OJeg5uA8lRabutnzm4JOr5lPE+57xfFKO7EHaX6oFI6HxhYFA4wd32IClE\n6fpDo+kTIUd7rba2Zjq2hf6xFJECAwEAAaN7MHkwCQYDVR0TBAIwADAsBglghkgB\nhvhCAQ0EHxYdT3BlblNTTCBHZW5lcmF0ZWQgQ2VydGlmaWNhdGUwHQYDVR0OBBYE\nFOhSP6PH+gt+PZjgIjhLGMMakFfMMB8GA1UdIwQYMBaAFMy18STW93imC2lMDsqI\ni6P0N+1hMA0GCSqGSIb3DQEBBQUAA4GBAH5nNEEP9HeBI7osag8SKRwu4VICQl5W\nAkHv08/kbVxd8B6ieI9si+DpHMQMl5Uk44Vz164aEAlkJFL3UEt8XJPpnYmrEM5X\njdF4+VmQqPcxsSlxRmk60VMpR+cTZURPweKtbTD8WkszaShG263k+4GWuiERxVJu\nuL1TUTvMbg6B\n-----END CERTIFICATE-----\n```\n\n直接输入  `openssl x509 -in ca.crt -pubkey`\n会看到两个公钥输出，如果将它转换成der格式文件的公钥文件，则没有任何多余输出\n`openssl x509 -in ca.crt -inform PEM -out ca.der -outform DER`\n\n## 十 openssl从PFX导出私钥、公钥\n从pfx提取密钥信息，并转换为key格式（pfx使用pkcs12模式补足）\n\n1. 提取密钥对（如果pfx证书已加密，会提示输入密码。）\n\n    `openssl pkcs12 -in 1.pfx -nocerts -nodes -out 1.key`\n    \n2. 从密钥对提取私钥\n\n    `openssl rsa -in  1.key -out 1_pri.key`\n    \n3. 从密钥对提取公钥\n\n    `openssl rsa -in 1.key -pubout -out 1_pub.key`\n    \n4. 因为RSA算法使用的是pkcs8模式补足，需要对提取的私钥进一步处理\n\n    `openssl pkcs8 -in 1_pri.key -out 1_pri.p8 -outform der -nocrypt -topk8`\n\n\n# 密钥库文件格式[Keystore]\n\n| 格式 | 扩展名 | 描述 | 特点 |\n| ---- | ---- | ---- | ---- |\n| JKS |.jks/.ks | [Java Keystore] 密钥库的Java实现版本，provider为SUN |密钥库和私钥用不同的密码进行保护|\n|JCEKS |.jce |[JCE Keystore] 密钥库的JCE实现版本，provider为SUN JCE |相对于JKS安全级别更高，保护Keystore私钥时采用TripleDES |\n|PKCS12 |.p12/.pfx |[PKCS #12] 个人信息交换语法标准 |1、包含私钥、公钥及其证书<br> 2、密钥库和私钥用相同密码进行保护 |\n|BKS |.bks |Bouncycastle Keystore] 密钥库的BC实现版本，provider为BC |基于JCE实现 |\n|UBER |.ubr |[Bouncycastle UBER Keystore] 密钥库的BC更安全实现版本，provider为BC | |\n\n# 证书文件格式[Certificate] \n\n| 格式 | 扩展名 | 描述 | 特点 |\n| ---- | ---- | ---- | ---- |\n|DER |.cer/.crt/.rsa  |[ASN .1 DER] 用于存放证书  |不含私钥、二进制 |\n|PKCS7 |.p7b/.p7r  |[PKCS #7] 加密信息语法标准  |1、p7b以树状展示证书链，不含私钥<br> 2、p7r为CA对证书请求签名的回复，只能用于导入 |\n|CMS |.p7c/.p7m/.p7s  |[Cryptographic Message Syntax]  |1、p7c只保存证书<br> 2、p7m：signature with enveloped data<br> 3、p7s：时间戳签名文件 |\n| PEM |.pem |[Printable Encoded Message] |1、该编码格式在RFC1421中定义，其实PEM是[Privacy-Enhanced Mail]的简写，但他也同样广泛运用于密钥管理<br> 2、ASCII文件<br> 3、一般基于base 64编码 |\n|PKCS10 |.p10/.csr |[PKCS #10] 公钥加密标准[Certificate Signing Request]|1、证书签名请求文件<br> 2、ASCII文件<br> 3、CA签名后以p7r文件回复<br> |\n|SPC |.pvk/.spc |[Software Publishing Certificate] |微软公司特有的双证书文件格式，经常用于代码签名，其中 pvk 用于保存私钥, spc 用于保存公钥 \n\n\n\n","source":"_posts/常见证书格式及相互转换.md","raw":"---\ntitle: 常见证书格式及相互转换\ntags: 证书\ndate: 2017-08-16 17:50:27\n---\n\n\n# 常见证书格式及相互转换\n\nPKCS 全称是 Public-Key Cryptography Standards ，是由 RSA 实验室与其它安全系统开发商为促进公钥密码的发展而制订的一系列标准，PKCS 目前共发布过 15 个标准。 \n\n常用的有：\nPKCS#7 Cryptographic Message Syntax Standard\nPKCS#10 Certification Request Standard\nPKCS#12 Personal Information Exchange Syntax Standard\n\n\nX.509是常见通用的证书格式。所有的证书都符合为Public Key Infrastructure (PKI) 制定的 ITU-T X509 国际标准。\n\n\nPKCS#7 常用的后缀是： .P7B .P7C .SPC\nPKCS#12 常用的后缀有： .P12 .PFX\nX.509 DER 编码(ASCII)的后缀是： .DER .CER .CRT\nX.509 PAM 编码(Base64)的后缀是： .PEM .CER .CRT\n.cer/.crt是用于存放证书，它是2进制形式存放的，不含私钥。\n.pem跟crt/cer的区别是它以Ascii来表示。\npfx/p12用于存放个人证书/私钥，他通常包含保护密码，2进制方式\np10是证书请求\np7r是CA对证书请求的回复，只用于导入\np7b以树状展示证书链(certificate chain)，同时也支持单个证书，不含私钥。\n\n\nder,cer文件一般是二进制格式的，只放证书，不含私钥\ncrt文件可能是二进制的，也可能是文本格式的，应该以文本格式居多，功能同der/cer\npem文件一般是文本格式的，可以放证书或者私钥，或者两者都有\npem如果只含私钥的话，一般用.key扩展名，而且可以有密码保护\npfx,p12文件是二进制格式，同时含私钥和证书，通常有保护密码\n\n\n\n1. 怎么判断是文本格式还是二进制？\n\n    用记事本打开，如果是规则的数字字母，如\n\n    ```\n    —–BEGIN CERTIFICATE—–\n    MIIE9jCCA96gAwIBAgIQVXD9d9wgivhJM//a3VIcDjANBgkqhkiG9w0BAQUFADBy\n    —–END CERTIFICATE—–\n    ```\n\n    就是文本的。\n\n    上面的`—–BEGIN CERTIFICATE—–`，说明这是一个证书；\n    如果是`—–BEGIN RSA PRIVATE KEY—–`，说明这是一个私钥，文本格式的私钥，也可能有密码保护；\n\n2. 文本格式怎么变成二进制？\n\n    从程序角度来说，去掉前后的—-行，剩下的去掉回车，用base64解码，就得到二进制了,不过一般都用命令行openssl完成这个工作；\n\n## 一 用openssl创建CA证书的RSA密钥(PEM格式)：\n```\nopenssl genrsa -des3 -out ca.key 1024\n```\n\n## 二 用openssl创建CA证书(PEM格式,假如有效期为一年)：\n```\nopenssl req -new -x509 -days 365 -key ca.key -out ca.crt -config openssl.cnf\n//openssl是可以生成DER格式的CA证书的，最好用IE将PEM格式的CA证书转换成DER格式的CA证书。\n```\n\n## 三 x509到pfx\n```\npkcs12 -export –in keys/client1.crt -inkey keys/client1.key -out keys/client1.pfx\n```\n\n## 四 PEM格式的ca.key转换为Microsoft可以识别的pvk格式。\n```\npvk -in ca.key -out ca.pvk -nocrypt -topvk\n```\n\n## 五 PKCS#12 到 PEM 的转换\n```\nopenssl pkcs12 -nocerts -nodes -in cert.p12 -out private.pem\n//验证 openssl pkcs12 -clcerts -nokeys -in cert.p12 -out cert.pem\n```\n\n## 六 从 PFX 格式文件中提取私钥格式文件 (.key)\n```\nopenssl pkcs12 -in mycert.pfx -nocerts -nodes -out mycert.key\n```\n\n## 七 转换 pem 到到 spc\n```\nopenssl crl2pkcs7 -nocrl -certfile venus.pem -outform DER -out venus.spc\n//用 -outform -inform 指定 DER 还是 PAM 格式。例如：\nopenssl x509 -in Cert.pem -inform PEM -out cert.der -outform DER\n```\n\n## 八 PEM 到 PKCS#12 的转换\n```\nopenssl pkcs12 -export -in Cert.pem -out Cert.p12 -inkey key.pem\n```\n\n## 九 从用户证书 server.crt提取出公钥文件\n```\nopenssl x509 -outform PEM -in server/server.crt -pubkey -out server/server.pubkey\n\n<!--\n-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDYhJizzt4+zhLMTSjDk0rd6MlK\nxBYKIp972+Wc9KSpOs5LGQ+2802mlr6dSDWJJhJShArqOIKgxNE7ZBZYlGeDo4l6\nDm4DyVFpu62fObgk6vmU8T7nvF8Uo7sQdpfqgUjofGFgUDjB3fYgKUTp+kOj6RMh\nR3uttrZmOraF/rEUkQIDAQAB\n-----END PUBLIC KEY-----\n-->\n```\n\n可以显示公钥信息，手动将其中内容复制到一个文件中做公钥测试成功，但是此命令输出的文件内容不是公钥信息，内容如下：\n```\n-----BEGIN CERTIFICATE-----\nMIICpTCCAg6gAwIBAgIBATANBgkqhkiG9w0BAQUFADBFMQswCQYDVQQGEwJjbjEQ\nMA4GA1UECBMHYmVpamluZzEMMAoGA1UEChMDYW9lMRYwFAYDVQQDEw13d3cuenlu\nZXQubXRuMB4XDTEzMDYwMjAxMjIxNloXDTE0MDYwMjAxMjIxNlowbzELMAkGA1UE\nBhMCY24xEDAOBgNVBAgMB2JlaWppbmcxDDAKBgNVBAoMA0FPRTEPMA0GA1UEAwwG\nd2l6YXJkMQwwCgYDVQQLDANjb3AxITAfBgkqhkiG9w0BCQEWEnd6aGgxOTg4QGdt\nYWlsLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA2ISYs87ePs4SzE0o\nw5NK3ejJSsQWCiKfe9vlnPSkqTrOSxkPtvNNppa+nUg1iSYSUoQK6jiCoMTRO2QW\nWJRng6OJeg5uA8lRabutnzm4JOr5lPE+57xfFKO7EHaX6oFI6HxhYFA4wd32IClE\n6fpDo+kTIUd7rba2Zjq2hf6xFJECAwEAAaN7MHkwCQYDVR0TBAIwADAsBglghkgB\nhvhCAQ0EHxYdT3BlblNTTCBHZW5lcmF0ZWQgQ2VydGlmaWNhdGUwHQYDVR0OBBYE\nFOhSP6PH+gt+PZjgIjhLGMMakFfMMB8GA1UdIwQYMBaAFMy18STW93imC2lMDsqI\ni6P0N+1hMA0GCSqGSIb3DQEBBQUAA4GBAH5nNEEP9HeBI7osag8SKRwu4VICQl5W\nAkHv08/kbVxd8B6ieI9si+DpHMQMl5Uk44Vz164aEAlkJFL3UEt8XJPpnYmrEM5X\njdF4+VmQqPcxsSlxRmk60VMpR+cTZURPweKtbTD8WkszaShG263k+4GWuiERxVJu\nuL1TUTvMbg6B\n-----END CERTIFICATE-----\n```\n\n直接输入  `openssl x509 -in ca.crt -pubkey`\n会看到两个公钥输出，如果将它转换成der格式文件的公钥文件，则没有任何多余输出\n`openssl x509 -in ca.crt -inform PEM -out ca.der -outform DER`\n\n## 十 openssl从PFX导出私钥、公钥\n从pfx提取密钥信息，并转换为key格式（pfx使用pkcs12模式补足）\n\n1. 提取密钥对（如果pfx证书已加密，会提示输入密码。）\n\n    `openssl pkcs12 -in 1.pfx -nocerts -nodes -out 1.key`\n    \n2. 从密钥对提取私钥\n\n    `openssl rsa -in  1.key -out 1_pri.key`\n    \n3. 从密钥对提取公钥\n\n    `openssl rsa -in 1.key -pubout -out 1_pub.key`\n    \n4. 因为RSA算法使用的是pkcs8模式补足，需要对提取的私钥进一步处理\n\n    `openssl pkcs8 -in 1_pri.key -out 1_pri.p8 -outform der -nocrypt -topk8`\n\n\n# 密钥库文件格式[Keystore]\n\n| 格式 | 扩展名 | 描述 | 特点 |\n| ---- | ---- | ---- | ---- |\n| JKS |.jks/.ks | [Java Keystore] 密钥库的Java实现版本，provider为SUN |密钥库和私钥用不同的密码进行保护|\n|JCEKS |.jce |[JCE Keystore] 密钥库的JCE实现版本，provider为SUN JCE |相对于JKS安全级别更高，保护Keystore私钥时采用TripleDES |\n|PKCS12 |.p12/.pfx |[PKCS #12] 个人信息交换语法标准 |1、包含私钥、公钥及其证书<br> 2、密钥库和私钥用相同密码进行保护 |\n|BKS |.bks |Bouncycastle Keystore] 密钥库的BC实现版本，provider为BC |基于JCE实现 |\n|UBER |.ubr |[Bouncycastle UBER Keystore] 密钥库的BC更安全实现版本，provider为BC | |\n\n# 证书文件格式[Certificate] \n\n| 格式 | 扩展名 | 描述 | 特点 |\n| ---- | ---- | ---- | ---- |\n|DER |.cer/.crt/.rsa  |[ASN .1 DER] 用于存放证书  |不含私钥、二进制 |\n|PKCS7 |.p7b/.p7r  |[PKCS #7] 加密信息语法标准  |1、p7b以树状展示证书链，不含私钥<br> 2、p7r为CA对证书请求签名的回复，只能用于导入 |\n|CMS |.p7c/.p7m/.p7s  |[Cryptographic Message Syntax]  |1、p7c只保存证书<br> 2、p7m：signature with enveloped data<br> 3、p7s：时间戳签名文件 |\n| PEM |.pem |[Printable Encoded Message] |1、该编码格式在RFC1421中定义，其实PEM是[Privacy-Enhanced Mail]的简写，但他也同样广泛运用于密钥管理<br> 2、ASCII文件<br> 3、一般基于base 64编码 |\n|PKCS10 |.p10/.csr |[PKCS #10] 公钥加密标准[Certificate Signing Request]|1、证书签名请求文件<br> 2、ASCII文件<br> 3、CA签名后以p7r文件回复<br> |\n|SPC |.pvk/.spc |[Software Publishing Certificate] |微软公司特有的双证书文件格式，经常用于代码签名，其中 pvk 用于保存私钥, spc 用于保存公钥 \n\n\n\n","slug":"常见证书格式及相互转换","published":1,"updated":"2018-04-24T08:09:12.676Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1k3jktm0006jz6yngqeprnk","content":"<h1 id=\"常见证书格式及相互转换\"><a href=\"#常见证书格式及相互转换\" class=\"headerlink\" title=\"常见证书格式及相互转换\"></a>常见证书格式及相互转换</h1><p>PKCS 全称是 Public-Key Cryptography Standards ，是由 RSA 实验室与其它安全系统开发商为促进公钥密码的发展而制订的一系列标准，PKCS 目前共发布过 15 个标准。 </p>\n<p>常用的有：<br>PKCS#7 Cryptographic Message Syntax Standard<br>PKCS#10 Certification Request Standard<br>PKCS#12 Personal Information Exchange Syntax Standard</p>\n<p>X.509是常见通用的证书格式。所有的证书都符合为Public Key Infrastructure (PKI) 制定的 ITU-T X509 国际标准。</p>\n<p>PKCS#7 常用的后缀是： .P7B .P7C .SPC<br>PKCS#12 常用的后缀有： .P12 .PFX<br>X.509 DER 编码(ASCII)的后缀是： .DER .CER .CRT<br>X.509 PAM 编码(Base64)的后缀是： .PEM .CER .CRT<br>.cer/.crt是用于存放证书，它是2进制形式存放的，不含私钥。<br>.pem跟crt/cer的区别是它以Ascii来表示。<br>pfx/p12用于存放个人证书/私钥，他通常包含保护密码，2进制方式<br>p10是证书请求<br>p7r是CA对证书请求的回复，只用于导入<br>p7b以树状展示证书链(certificate chain)，同时也支持单个证书，不含私钥。</p>\n<p>der,cer文件一般是二进制格式的，只放证书，不含私钥<br>crt文件可能是二进制的，也可能是文本格式的，应该以文本格式居多，功能同der/cer<br>pem文件一般是文本格式的，可以放证书或者私钥，或者两者都有<br>pem如果只含私钥的话，一般用.key扩展名，而且可以有密码保护<br>pfx,p12文件是二进制格式，同时含私钥和证书，通常有保护密码</p>\n<ol>\n<li><p>怎么判断是文本格式还是二进制？</p>\n<p> 用记事本打开，如果是规则的数字字母，如</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">—–BEGIN CERTIFICATE—–</span><br><span class=\"line\">MIIE9jCCA96gAwIBAgIQVXD9d9wgivhJM//a3VIcDjANBgkqhkiG9w0BAQUFADBy</span><br><span class=\"line\">—–END CERTIFICATE—–</span><br></pre></td></tr></table></figure>\n<p> 就是文本的。</p>\n<p> 上面的<code>—–BEGIN CERTIFICATE—–</code>，说明这是一个证书；<br> 如果是<code>—–BEGIN RSA PRIVATE KEY—–</code>，说明这是一个私钥，文本格式的私钥，也可能有密码保护；</p>\n</li>\n<li><p>文本格式怎么变成二进制？</p>\n<p> 从程序角度来说，去掉前后的—-行，剩下的去掉回车，用base64解码，就得到二进制了,不过一般都用命令行openssl完成这个工作；</p>\n</li>\n</ol>\n<h2 id=\"一-用openssl创建CA证书的RSA密钥-PEM格式-：\"><a href=\"#一-用openssl创建CA证书的RSA密钥-PEM格式-：\" class=\"headerlink\" title=\"一 用openssl创建CA证书的RSA密钥(PEM格式)：\"></a>一 用openssl创建CA证书的RSA密钥(PEM格式)：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl genrsa -des3 -out ca.key 1024</span><br></pre></td></tr></table></figure>\n<h2 id=\"二-用openssl创建CA证书-PEM格式-假如有效期为一年-：\"><a href=\"#二-用openssl创建CA证书-PEM格式-假如有效期为一年-：\" class=\"headerlink\" title=\"二 用openssl创建CA证书(PEM格式,假如有效期为一年)：\"></a>二 用openssl创建CA证书(PEM格式,假如有效期为一年)：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl req -new -x509 -days 365 -key ca.key -out ca.crt -config openssl.cnf</span><br><span class=\"line\">//openssl是可以生成DER格式的CA证书的，最好用IE将PEM格式的CA证书转换成DER格式的CA证书。</span><br></pre></td></tr></table></figure>\n<h2 id=\"三-x509到pfx\"><a href=\"#三-x509到pfx\" class=\"headerlink\" title=\"三 x509到pfx\"></a>三 x509到pfx</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pkcs12 -export –in keys/client1.crt -inkey keys/client1.key -out keys/client1.pfx</span><br></pre></td></tr></table></figure>\n<h2 id=\"四-PEM格式的ca-key转换为Microsoft可以识别的pvk格式。\"><a href=\"#四-PEM格式的ca-key转换为Microsoft可以识别的pvk格式。\" class=\"headerlink\" title=\"四 PEM格式的ca.key转换为Microsoft可以识别的pvk格式。\"></a>四 PEM格式的ca.key转换为Microsoft可以识别的pvk格式。</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pvk -in ca.key -out ca.pvk -nocrypt -topvk</span><br></pre></td></tr></table></figure>\n<h2 id=\"五-PKCS-12-到-PEM-的转换\"><a href=\"#五-PKCS-12-到-PEM-的转换\" class=\"headerlink\" title=\"五 PKCS#12 到 PEM 的转换\"></a>五 PKCS#12 到 PEM 的转换</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl pkcs12 -nocerts -nodes -in cert.p12 -out private.pem</span><br><span class=\"line\">//验证 openssl pkcs12 -clcerts -nokeys -in cert.p12 -out cert.pem</span><br></pre></td></tr></table></figure>\n<h2 id=\"六-从-PFX-格式文件中提取私钥格式文件-key\"><a href=\"#六-从-PFX-格式文件中提取私钥格式文件-key\" class=\"headerlink\" title=\"六 从 PFX 格式文件中提取私钥格式文件 (.key)\"></a>六 从 PFX 格式文件中提取私钥格式文件 (.key)</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl pkcs12 -in mycert.pfx -nocerts -nodes -out mycert.key</span><br></pre></td></tr></table></figure>\n<h2 id=\"七-转换-pem-到到-spc\"><a href=\"#七-转换-pem-到到-spc\" class=\"headerlink\" title=\"七 转换 pem 到到 spc\"></a>七 转换 pem 到到 spc</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl crl2pkcs7 -nocrl -certfile venus.pem -outform DER -out venus.spc</span><br><span class=\"line\">//用 -outform -inform 指定 DER 还是 PAM 格式。例如：</span><br><span class=\"line\">openssl x509 -in Cert.pem -inform PEM -out cert.der -outform DER</span><br></pre></td></tr></table></figure>\n<h2 id=\"八-PEM-到-PKCS-12-的转换\"><a href=\"#八-PEM-到-PKCS-12-的转换\" class=\"headerlink\" title=\"八 PEM 到 PKCS#12 的转换\"></a>八 PEM 到 PKCS#12 的转换</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl pkcs12 -export -in Cert.pem -out Cert.p12 -inkey key.pem</span><br></pre></td></tr></table></figure>\n<h2 id=\"九-从用户证书-server-crt提取出公钥文件\"><a href=\"#九-从用户证书-server-crt提取出公钥文件\" class=\"headerlink\" title=\"九 从用户证书 server.crt提取出公钥文件\"></a>九 从用户证书 server.crt提取出公钥文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl x509 -outform PEM -in server/server.crt -pubkey -out server/server.pubkey</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--</span><br><span class=\"line\">-----BEGIN PUBLIC KEY-----</span><br><span class=\"line\">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDYhJizzt4+zhLMTSjDk0rd6MlK</span><br><span class=\"line\">xBYKIp972+Wc9KSpOs5LGQ+2802mlr6dSDWJJhJShArqOIKgxNE7ZBZYlGeDo4l6</span><br><span class=\"line\">Dm4DyVFpu62fObgk6vmU8T7nvF8Uo7sQdpfqgUjofGFgUDjB3fYgKUTp+kOj6RMh</span><br><span class=\"line\">R3uttrZmOraF/rEUkQIDAQAB</span><br><span class=\"line\">-----END PUBLIC KEY-----</span><br><span class=\"line\">--&gt;</span><br></pre></td></tr></table></figure>\n<p>可以显示公钥信息，手动将其中内容复制到一个文件中做公钥测试成功，但是此命令输出的文件内容不是公钥信息，内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----BEGIN CERTIFICATE-----</span><br><span class=\"line\">MIICpTCCAg6gAwIBAgIBATANBgkqhkiG9w0BAQUFADBFMQswCQYDVQQGEwJjbjEQ</span><br><span class=\"line\">MA4GA1UECBMHYmVpamluZzEMMAoGA1UEChMDYW9lMRYwFAYDVQQDEw13d3cuenlu</span><br><span class=\"line\">ZXQubXRuMB4XDTEzMDYwMjAxMjIxNloXDTE0MDYwMjAxMjIxNlowbzELMAkGA1UE</span><br><span class=\"line\">BhMCY24xEDAOBgNVBAgMB2JlaWppbmcxDDAKBgNVBAoMA0FPRTEPMA0GA1UEAwwG</span><br><span class=\"line\">d2l6YXJkMQwwCgYDVQQLDANjb3AxITAfBgkqhkiG9w0BCQEWEnd6aGgxOTg4QGdt</span><br><span class=\"line\">YWlsLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA2ISYs87ePs4SzE0o</span><br><span class=\"line\">w5NK3ejJSsQWCiKfe9vlnPSkqTrOSxkPtvNNppa+nUg1iSYSUoQK6jiCoMTRO2QW</span><br><span class=\"line\">WJRng6OJeg5uA8lRabutnzm4JOr5lPE+57xfFKO7EHaX6oFI6HxhYFA4wd32IClE</span><br><span class=\"line\">6fpDo+kTIUd7rba2Zjq2hf6xFJECAwEAAaN7MHkwCQYDVR0TBAIwADAsBglghkgB</span><br><span class=\"line\">hvhCAQ0EHxYdT3BlblNTTCBHZW5lcmF0ZWQgQ2VydGlmaWNhdGUwHQYDVR0OBBYE</span><br><span class=\"line\">FOhSP6PH+gt+PZjgIjhLGMMakFfMMB8GA1UdIwQYMBaAFMy18STW93imC2lMDsqI</span><br><span class=\"line\">i6P0N+1hMA0GCSqGSIb3DQEBBQUAA4GBAH5nNEEP9HeBI7osag8SKRwu4VICQl5W</span><br><span class=\"line\">AkHv08/kbVxd8B6ieI9si+DpHMQMl5Uk44Vz164aEAlkJFL3UEt8XJPpnYmrEM5X</span><br><span class=\"line\">jdF4+VmQqPcxsSlxRmk60VMpR+cTZURPweKtbTD8WkszaShG263k+4GWuiERxVJu</span><br><span class=\"line\">uL1TUTvMbg6B</span><br><span class=\"line\">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure></p>\n<p>直接输入  <code>openssl x509 -in ca.crt -pubkey</code><br>会看到两个公钥输出，如果将它转换成der格式文件的公钥文件，则没有任何多余输出<br><code>openssl x509 -in ca.crt -inform PEM -out ca.der -outform DER</code></p>\n<h2 id=\"十-openssl从PFX导出私钥、公钥\"><a href=\"#十-openssl从PFX导出私钥、公钥\" class=\"headerlink\" title=\"十 openssl从PFX导出私钥、公钥\"></a>十 openssl从PFX导出私钥、公钥</h2><p>从pfx提取密钥信息，并转换为key格式（pfx使用pkcs12模式补足）</p>\n<ol>\n<li><p>提取密钥对（如果pfx证书已加密，会提示输入密码。）</p>\n<p> <code>openssl pkcs12 -in 1.pfx -nocerts -nodes -out 1.key</code></p>\n</li>\n<li><p>从密钥对提取私钥</p>\n<p> <code>openssl rsa -in  1.key -out 1_pri.key</code></p>\n</li>\n<li><p>从密钥对提取公钥</p>\n<p> <code>openssl rsa -in 1.key -pubout -out 1_pub.key</code></p>\n</li>\n<li><p>因为RSA算法使用的是pkcs8模式补足，需要对提取的私钥进一步处理</p>\n<p> <code>openssl pkcs8 -in 1_pri.key -out 1_pri.p8 -outform der -nocrypt -topk8</code></p>\n</li>\n</ol>\n<h1 id=\"密钥库文件格式-Keystore\"><a href=\"#密钥库文件格式-Keystore\" class=\"headerlink\" title=\"密钥库文件格式[Keystore]\"></a>密钥库文件格式[Keystore]</h1><table>\n<thead>\n<tr>\n<th>格式</th>\n<th>扩展名</th>\n<th>描述</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JKS</td>\n<td>.jks/.ks</td>\n<td>[Java Keystore] 密钥库的Java实现版本，provider为SUN</td>\n<td>密钥库和私钥用不同的密码进行保护</td>\n</tr>\n<tr>\n<td>JCEKS</td>\n<td>.jce</td>\n<td>[JCE Keystore] 密钥库的JCE实现版本，provider为SUN JCE</td>\n<td>相对于JKS安全级别更高，保护Keystore私钥时采用TripleDES</td>\n</tr>\n<tr>\n<td>PKCS12</td>\n<td>.p12/.pfx</td>\n<td>[PKCS #12] 个人信息交换语法标准</td>\n<td>1、包含私钥、公钥及其证书<br> 2、密钥库和私钥用相同密码进行保护</td>\n</tr>\n<tr>\n<td>BKS</td>\n<td>.bks</td>\n<td>Bouncycastle Keystore] 密钥库的BC实现版本，provider为BC</td>\n<td>基于JCE实现</td>\n</tr>\n<tr>\n<td>UBER</td>\n<td>.ubr</td>\n<td>[Bouncycastle UBER Keystore] 密钥库的BC更安全实现版本，provider为BC</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"证书文件格式-Certificate\"><a href=\"#证书文件格式-Certificate\" class=\"headerlink\" title=\"证书文件格式[Certificate]\"></a>证书文件格式[Certificate]</h1><table>\n<thead>\n<tr>\n<th>格式</th>\n<th>扩展名</th>\n<th>描述</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DER</td>\n<td>.cer/.crt/.rsa</td>\n<td>[ASN .1 DER] 用于存放证书</td>\n<td>不含私钥、二进制</td>\n</tr>\n<tr>\n<td>PKCS7</td>\n<td>.p7b/.p7r</td>\n<td>[PKCS #7] 加密信息语法标准</td>\n<td>1、p7b以树状展示证书链，不含私钥<br> 2、p7r为CA对证书请求签名的回复，只能用于导入</td>\n</tr>\n<tr>\n<td>CMS</td>\n<td>.p7c/.p7m/.p7s</td>\n<td>[Cryptographic Message Syntax]</td>\n<td>1、p7c只保存证书<br> 2、p7m：signature with enveloped data<br> 3、p7s：时间戳签名文件</td>\n</tr>\n<tr>\n<td>PEM</td>\n<td>.pem</td>\n<td>[Printable Encoded Message]</td>\n<td>1、该编码格式在RFC1421中定义，其实PEM是[Privacy-Enhanced Mail]的简写，但他也同样广泛运用于密钥管理<br> 2、ASCII文件<br> 3、一般基于base 64编码</td>\n</tr>\n<tr>\n<td>PKCS10</td>\n<td>.p10/.csr</td>\n<td>[PKCS #10] 公钥加密标准[Certificate Signing Request]</td>\n<td>1、证书签名请求文件<br> 2、ASCII文件<br> 3、CA签名后以p7r文件回复<br></td>\n</tr>\n<tr>\n<td>SPC</td>\n<td>.pvk/.spc</td>\n<td>[Software Publishing Certificate]</td>\n<td>微软公司特有的双证书文件格式，经常用于代码签名，其中 pvk 用于保存私钥, spc 用于保存公钥 </td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"常见证书格式及相互转换\"><a href=\"#常见证书格式及相互转换\" class=\"headerlink\" title=\"常见证书格式及相互转换\"></a>常见证书格式及相互转换</h1><p>PKCS 全称是 Public-Key Cryptography Standards ，是由 RSA 实验室与其它安全系统开发商为促进公钥密码的发展而制订的一系列标准，PKCS 目前共发布过 15 个标准。 </p>\n<p>常用的有：<br>PKCS#7 Cryptographic Message Syntax Standard<br>PKCS#10 Certification Request Standard<br>PKCS#12 Personal Information Exchange Syntax Standard</p>\n<p>X.509是常见通用的证书格式。所有的证书都符合为Public Key Infrastructure (PKI) 制定的 ITU-T X509 国际标准。</p>\n<p>PKCS#7 常用的后缀是： .P7B .P7C .SPC<br>PKCS#12 常用的后缀有： .P12 .PFX<br>X.509 DER 编码(ASCII)的后缀是： .DER .CER .CRT<br>X.509 PAM 编码(Base64)的后缀是： .PEM .CER .CRT<br>.cer/.crt是用于存放证书，它是2进制形式存放的，不含私钥。<br>.pem跟crt/cer的区别是它以Ascii来表示。<br>pfx/p12用于存放个人证书/私钥，他通常包含保护密码，2进制方式<br>p10是证书请求<br>p7r是CA对证书请求的回复，只用于导入<br>p7b以树状展示证书链(certificate chain)，同时也支持单个证书，不含私钥。</p>\n<p>der,cer文件一般是二进制格式的，只放证书，不含私钥<br>crt文件可能是二进制的，也可能是文本格式的，应该以文本格式居多，功能同der/cer<br>pem文件一般是文本格式的，可以放证书或者私钥，或者两者都有<br>pem如果只含私钥的话，一般用.key扩展名，而且可以有密码保护<br>pfx,p12文件是二进制格式，同时含私钥和证书，通常有保护密码</p>\n<ol>\n<li><p>怎么判断是文本格式还是二进制？</p>\n<p> 用记事本打开，如果是规则的数字字母，如</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">—–BEGIN CERTIFICATE—–</span><br><span class=\"line\">MIIE9jCCA96gAwIBAgIQVXD9d9wgivhJM//a3VIcDjANBgkqhkiG9w0BAQUFADBy</span><br><span class=\"line\">—–END CERTIFICATE—–</span><br></pre></td></tr></table></figure>\n<p> 就是文本的。</p>\n<p> 上面的<code>—–BEGIN CERTIFICATE—–</code>，说明这是一个证书；<br> 如果是<code>—–BEGIN RSA PRIVATE KEY—–</code>，说明这是一个私钥，文本格式的私钥，也可能有密码保护；</p>\n</li>\n<li><p>文本格式怎么变成二进制？</p>\n<p> 从程序角度来说，去掉前后的—-行，剩下的去掉回车，用base64解码，就得到二进制了,不过一般都用命令行openssl完成这个工作；</p>\n</li>\n</ol>\n<h2 id=\"一-用openssl创建CA证书的RSA密钥-PEM格式-：\"><a href=\"#一-用openssl创建CA证书的RSA密钥-PEM格式-：\" class=\"headerlink\" title=\"一 用openssl创建CA证书的RSA密钥(PEM格式)：\"></a>一 用openssl创建CA证书的RSA密钥(PEM格式)：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl genrsa -des3 -out ca.key 1024</span><br></pre></td></tr></table></figure>\n<h2 id=\"二-用openssl创建CA证书-PEM格式-假如有效期为一年-：\"><a href=\"#二-用openssl创建CA证书-PEM格式-假如有效期为一年-：\" class=\"headerlink\" title=\"二 用openssl创建CA证书(PEM格式,假如有效期为一年)：\"></a>二 用openssl创建CA证书(PEM格式,假如有效期为一年)：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl req -new -x509 -days 365 -key ca.key -out ca.crt -config openssl.cnf</span><br><span class=\"line\">//openssl是可以生成DER格式的CA证书的，最好用IE将PEM格式的CA证书转换成DER格式的CA证书。</span><br></pre></td></tr></table></figure>\n<h2 id=\"三-x509到pfx\"><a href=\"#三-x509到pfx\" class=\"headerlink\" title=\"三 x509到pfx\"></a>三 x509到pfx</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pkcs12 -export –in keys/client1.crt -inkey keys/client1.key -out keys/client1.pfx</span><br></pre></td></tr></table></figure>\n<h2 id=\"四-PEM格式的ca-key转换为Microsoft可以识别的pvk格式。\"><a href=\"#四-PEM格式的ca-key转换为Microsoft可以识别的pvk格式。\" class=\"headerlink\" title=\"四 PEM格式的ca.key转换为Microsoft可以识别的pvk格式。\"></a>四 PEM格式的ca.key转换为Microsoft可以识别的pvk格式。</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pvk -in ca.key -out ca.pvk -nocrypt -topvk</span><br></pre></td></tr></table></figure>\n<h2 id=\"五-PKCS-12-到-PEM-的转换\"><a href=\"#五-PKCS-12-到-PEM-的转换\" class=\"headerlink\" title=\"五 PKCS#12 到 PEM 的转换\"></a>五 PKCS#12 到 PEM 的转换</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl pkcs12 -nocerts -nodes -in cert.p12 -out private.pem</span><br><span class=\"line\">//验证 openssl pkcs12 -clcerts -nokeys -in cert.p12 -out cert.pem</span><br></pre></td></tr></table></figure>\n<h2 id=\"六-从-PFX-格式文件中提取私钥格式文件-key\"><a href=\"#六-从-PFX-格式文件中提取私钥格式文件-key\" class=\"headerlink\" title=\"六 从 PFX 格式文件中提取私钥格式文件 (.key)\"></a>六 从 PFX 格式文件中提取私钥格式文件 (.key)</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl pkcs12 -in mycert.pfx -nocerts -nodes -out mycert.key</span><br></pre></td></tr></table></figure>\n<h2 id=\"七-转换-pem-到到-spc\"><a href=\"#七-转换-pem-到到-spc\" class=\"headerlink\" title=\"七 转换 pem 到到 spc\"></a>七 转换 pem 到到 spc</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl crl2pkcs7 -nocrl -certfile venus.pem -outform DER -out venus.spc</span><br><span class=\"line\">//用 -outform -inform 指定 DER 还是 PAM 格式。例如：</span><br><span class=\"line\">openssl x509 -in Cert.pem -inform PEM -out cert.der -outform DER</span><br></pre></td></tr></table></figure>\n<h2 id=\"八-PEM-到-PKCS-12-的转换\"><a href=\"#八-PEM-到-PKCS-12-的转换\" class=\"headerlink\" title=\"八 PEM 到 PKCS#12 的转换\"></a>八 PEM 到 PKCS#12 的转换</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl pkcs12 -export -in Cert.pem -out Cert.p12 -inkey key.pem</span><br></pre></td></tr></table></figure>\n<h2 id=\"九-从用户证书-server-crt提取出公钥文件\"><a href=\"#九-从用户证书-server-crt提取出公钥文件\" class=\"headerlink\" title=\"九 从用户证书 server.crt提取出公钥文件\"></a>九 从用户证书 server.crt提取出公钥文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl x509 -outform PEM -in server/server.crt -pubkey -out server/server.pubkey</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--</span><br><span class=\"line\">-----BEGIN PUBLIC KEY-----</span><br><span class=\"line\">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDYhJizzt4+zhLMTSjDk0rd6MlK</span><br><span class=\"line\">xBYKIp972+Wc9KSpOs5LGQ+2802mlr6dSDWJJhJShArqOIKgxNE7ZBZYlGeDo4l6</span><br><span class=\"line\">Dm4DyVFpu62fObgk6vmU8T7nvF8Uo7sQdpfqgUjofGFgUDjB3fYgKUTp+kOj6RMh</span><br><span class=\"line\">R3uttrZmOraF/rEUkQIDAQAB</span><br><span class=\"line\">-----END PUBLIC KEY-----</span><br><span class=\"line\">--&gt;</span><br></pre></td></tr></table></figure>\n<p>可以显示公钥信息，手动将其中内容复制到一个文件中做公钥测试成功，但是此命令输出的文件内容不是公钥信息，内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----BEGIN CERTIFICATE-----</span><br><span class=\"line\">MIICpTCCAg6gAwIBAgIBATANBgkqhkiG9w0BAQUFADBFMQswCQYDVQQGEwJjbjEQ</span><br><span class=\"line\">MA4GA1UECBMHYmVpamluZzEMMAoGA1UEChMDYW9lMRYwFAYDVQQDEw13d3cuenlu</span><br><span class=\"line\">ZXQubXRuMB4XDTEzMDYwMjAxMjIxNloXDTE0MDYwMjAxMjIxNlowbzELMAkGA1UE</span><br><span class=\"line\">BhMCY24xEDAOBgNVBAgMB2JlaWppbmcxDDAKBgNVBAoMA0FPRTEPMA0GA1UEAwwG</span><br><span class=\"line\">d2l6YXJkMQwwCgYDVQQLDANjb3AxITAfBgkqhkiG9w0BCQEWEnd6aGgxOTg4QGdt</span><br><span class=\"line\">YWlsLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA2ISYs87ePs4SzE0o</span><br><span class=\"line\">w5NK3ejJSsQWCiKfe9vlnPSkqTrOSxkPtvNNppa+nUg1iSYSUoQK6jiCoMTRO2QW</span><br><span class=\"line\">WJRng6OJeg5uA8lRabutnzm4JOr5lPE+57xfFKO7EHaX6oFI6HxhYFA4wd32IClE</span><br><span class=\"line\">6fpDo+kTIUd7rba2Zjq2hf6xFJECAwEAAaN7MHkwCQYDVR0TBAIwADAsBglghkgB</span><br><span class=\"line\">hvhCAQ0EHxYdT3BlblNTTCBHZW5lcmF0ZWQgQ2VydGlmaWNhdGUwHQYDVR0OBBYE</span><br><span class=\"line\">FOhSP6PH+gt+PZjgIjhLGMMakFfMMB8GA1UdIwQYMBaAFMy18STW93imC2lMDsqI</span><br><span class=\"line\">i6P0N+1hMA0GCSqGSIb3DQEBBQUAA4GBAH5nNEEP9HeBI7osag8SKRwu4VICQl5W</span><br><span class=\"line\">AkHv08/kbVxd8B6ieI9si+DpHMQMl5Uk44Vz164aEAlkJFL3UEt8XJPpnYmrEM5X</span><br><span class=\"line\">jdF4+VmQqPcxsSlxRmk60VMpR+cTZURPweKtbTD8WkszaShG263k+4GWuiERxVJu</span><br><span class=\"line\">uL1TUTvMbg6B</span><br><span class=\"line\">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure></p>\n<p>直接输入  <code>openssl x509 -in ca.crt -pubkey</code><br>会看到两个公钥输出，如果将它转换成der格式文件的公钥文件，则没有任何多余输出<br><code>openssl x509 -in ca.crt -inform PEM -out ca.der -outform DER</code></p>\n<h2 id=\"十-openssl从PFX导出私钥、公钥\"><a href=\"#十-openssl从PFX导出私钥、公钥\" class=\"headerlink\" title=\"十 openssl从PFX导出私钥、公钥\"></a>十 openssl从PFX导出私钥、公钥</h2><p>从pfx提取密钥信息，并转换为key格式（pfx使用pkcs12模式补足）</p>\n<ol>\n<li><p>提取密钥对（如果pfx证书已加密，会提示输入密码。）</p>\n<p> <code>openssl pkcs12 -in 1.pfx -nocerts -nodes -out 1.key</code></p>\n</li>\n<li><p>从密钥对提取私钥</p>\n<p> <code>openssl rsa -in  1.key -out 1_pri.key</code></p>\n</li>\n<li><p>从密钥对提取公钥</p>\n<p> <code>openssl rsa -in 1.key -pubout -out 1_pub.key</code></p>\n</li>\n<li><p>因为RSA算法使用的是pkcs8模式补足，需要对提取的私钥进一步处理</p>\n<p> <code>openssl pkcs8 -in 1_pri.key -out 1_pri.p8 -outform der -nocrypt -topk8</code></p>\n</li>\n</ol>\n<h1 id=\"密钥库文件格式-Keystore\"><a href=\"#密钥库文件格式-Keystore\" class=\"headerlink\" title=\"密钥库文件格式[Keystore]\"></a>密钥库文件格式[Keystore]</h1><table>\n<thead>\n<tr>\n<th>格式</th>\n<th>扩展名</th>\n<th>描述</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JKS</td>\n<td>.jks/.ks</td>\n<td>[Java Keystore] 密钥库的Java实现版本，provider为SUN</td>\n<td>密钥库和私钥用不同的密码进行保护</td>\n</tr>\n<tr>\n<td>JCEKS</td>\n<td>.jce</td>\n<td>[JCE Keystore] 密钥库的JCE实现版本，provider为SUN JCE</td>\n<td>相对于JKS安全级别更高，保护Keystore私钥时采用TripleDES</td>\n</tr>\n<tr>\n<td>PKCS12</td>\n<td>.p12/.pfx</td>\n<td>[PKCS #12] 个人信息交换语法标准</td>\n<td>1、包含私钥、公钥及其证书<br> 2、密钥库和私钥用相同密码进行保护</td>\n</tr>\n<tr>\n<td>BKS</td>\n<td>.bks</td>\n<td>Bouncycastle Keystore] 密钥库的BC实现版本，provider为BC</td>\n<td>基于JCE实现</td>\n</tr>\n<tr>\n<td>UBER</td>\n<td>.ubr</td>\n<td>[Bouncycastle UBER Keystore] 密钥库的BC更安全实现版本，provider为BC</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"证书文件格式-Certificate\"><a href=\"#证书文件格式-Certificate\" class=\"headerlink\" title=\"证书文件格式[Certificate]\"></a>证书文件格式[Certificate]</h1><table>\n<thead>\n<tr>\n<th>格式</th>\n<th>扩展名</th>\n<th>描述</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DER</td>\n<td>.cer/.crt/.rsa</td>\n<td>[ASN .1 DER] 用于存放证书</td>\n<td>不含私钥、二进制</td>\n</tr>\n<tr>\n<td>PKCS7</td>\n<td>.p7b/.p7r</td>\n<td>[PKCS #7] 加密信息语法标准</td>\n<td>1、p7b以树状展示证书链，不含私钥<br> 2、p7r为CA对证书请求签名的回复，只能用于导入</td>\n</tr>\n<tr>\n<td>CMS</td>\n<td>.p7c/.p7m/.p7s</td>\n<td>[Cryptographic Message Syntax]</td>\n<td>1、p7c只保存证书<br> 2、p7m：signature with enveloped data<br> 3、p7s：时间戳签名文件</td>\n</tr>\n<tr>\n<td>PEM</td>\n<td>.pem</td>\n<td>[Printable Encoded Message]</td>\n<td>1、该编码格式在RFC1421中定义，其实PEM是[Privacy-Enhanced Mail]的简写，但他也同样广泛运用于密钥管理<br> 2、ASCII文件<br> 3、一般基于base 64编码</td>\n</tr>\n<tr>\n<td>PKCS10</td>\n<td>.p10/.csr</td>\n<td>[PKCS #10] 公钥加密标准[Certificate Signing Request]</td>\n<td>1、证书签名请求文件<br> 2、ASCII文件<br> 3、CA签名后以p7r文件回复<br></td>\n</tr>\n<tr>\n<td>SPC</td>\n<td>.pvk/.spc</td>\n<td>[Software Publishing Certificate]</td>\n<td>微软公司特有的双证书文件格式，经常用于代码签名，其中 pvk 用于保存私钥, spc 用于保存公钥 </td>\n</tr>\n</tbody>\n</table>\n"},{"title":"iOS 面试题汇总","date":"2019-10-10T02:46:19.000Z","_content":"\n\n原文链接：https://blog.csdn.net/gsl111000/article/details/93629640\n\n1. 简单介绍下 NSURLConnection 类及+ sendSynchronousRequest:returningResponse:error:与– initWithRequest:delegate:两个方法的区别?\n\n    >答: NSURLConnection主要用于网络访问，其中+ sendSynchronousRequest:returningResponse:error:是同步访问数据，即当前线程会阻塞，并等待request的返回的response，而– initWithRequest:delegate:使用的是异步加载，当其完成网络访问后，会通过delegate回到主线程，并其委托的对象。\n\n2. 在项目什么时候选择使用GCD，什么时候选择NSOperation\n\n    >答: 项目中使用NSOperation的优点是NSOperation是对线程的高度抽象，在项目中使用它，会使项目的程序结构更好，子类化NSOperation的设计思路，是具有面向对象的优点(复用、封装)，使得实现是多线程支持，而接口简单，建议在复杂项目中使用。\n    项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线程操作，会节省代码量，而Block参数的使用，会是代码更为易读，建议在简单项目中使用。\n\n3. ViewController的didReceiveMemoryWarning怎么被调用\n\n    >答:[supper didReceiveMemoryWarning];\n\n4. 写一个setter方法用于完成@property(nonatomic, retain) NSString *name,写一个setter方法用于完成@property(nonatomic, copy) NSString *name\n\n    ```[object-c]\n    - (void)setName:(NSString *)str{\n        [str retain];\n        [_name release];\n        _name = str;\n    }\n    - (void)setName:(NSString *)str{\n        id t = [str copy];\n        [_name release];\n        _name = t;\n    }\n    ```\n\n5. 对于语句NSString *obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?\n\n    >答： 编译时是NSString的类型;运行时是NSData类型的对象\n\n6. Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?\n\n    >答：线程创建有三种方法：使用NSThread创建、使用GCD的dispatch、使用子类化的NSOperation,然后将其加入NSOperationQueue;在主线程执行代码，方法是performSelectorOnMainThread，如果想延时执行代码可以用performSelector:onThread:withObject:waitUntilDone:\n\n7. 浅复制和深复制的区别?\n\n    >答：浅层复制：只复制指向对象的指针，而不复制引用对象本身。\n深层复制：复制引用对象本身。\n\n8. PerformSelecter\n\n    >当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。\n当调用performSelector:onThread:时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。\n\n9. 优化你是从哪几方面着手？\n\n    >一、首页启动速度\n    启动过程中做的事情越少越好（尽可能将多个接口合并）\n    不在UI线程上作耗时的操作（数据的处理在子线程进行，处理完通知主线程刷新节目）\n    在合适的时机开始后台任务（例如在用户指引节目就可以开始准备加载的数据）\n    二、页面浏览速度\n    json的处理（iOS 自带的NSJSONSerialization，Jsonkit，SBJson）\n    数据的分页（后端数据多的话，就要分页返回，例如网易新闻，或者 微博记录）\n    数据压缩（大数据也可以压缩返回，减少流量，加快反应速度）\n    内容缓存（例如网易新闻的最新新闻列表都是要缓存到本地，从本地加载，可以缓存到内存，或者数据库，根据情况而定）\n    延时加载tab（比如app有5个tab，可以先加载第一个要显示的tab，其他的在显示时候加载，按需加载）\n    算法的优化（核心算法的优化，例如有些app 有个 联系人姓名用汉语拼音的首字母排序）\n    三、操作流畅度优化\n    Tableview 优化（tableview cell的加载优化）\n    ViewController加载优化（不同view之间的跳转，可以提前准备好数据）\n    四、数据库的优化\n    数据库设计上面的重构\n    查询语句的优化\n    分库分表（数据太多的时候，可以分不同的表或者库）\n    五、服务器端和客户端的交互优化\n    客户端尽量减少请求\n    服务端尽量做多的逻辑处理\n    服务器端和客户端采取推拉结合的方式（可以利用一些同步机制）\n    通信协议的优化（减少报文的大小）\n    电量使用优化（尽量不要使用后台运行）\n    六、非技术性能优化\n    产品设计的逻辑性（产品的设计一定要符合逻辑，或者逻辑尽量简单，否则会让程序员抓狂，有时候用了好大力气，才可以完成一个小小的逻辑设计问题）\n    界面交互的规范（每个模块的界面的交互尽量统一，符合操作习惯）\n    代码规范（这个可以隐形带来app 性能的提高，比如 用if else 还是switch ，或者是用！还是 ＝＝）\n    code review（坚持code Review 持续重构代码。减少代码的逻辑复杂度）\n\n10. 什么情况使用 weak 关键字，相比 assign 有什么不同？\n\n    >1.在ARC中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性。\n    2.自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,如自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。\n    IBOutlet连出来的视图属性为什么可以被设置成weak?\n    答：因为父控件的subViews数组已经对它有一个强引用。\n    不同点\n    assign 可以用非 OC 对象，而 weak 必须用于 OC 对象。\n    weak 表明该属性定义了一种“非拥有关系”。在属性所指的对象销毁时，属性值会自动清空(nil)\n\n11. 用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？\n\n    >答：用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的），为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。\n    1.因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。\n    2.如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。\n    总结：使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发送变化会无意间篡改不可变类型对象原来的值。\n\n12. runtime如何实现weak变量的自动置nil？\n\n    >runtime对注册的类，会进行布局，会将 weak 对象放入一个 hash 表中。用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会调用对象的 dealloc 方法，假设 weak 指向的对象内存地址是a，那么就会以a为key，在这个 weak hash表中搜索，找到所有以a为key的 weak 对象，从而设置为nil\n\n13. runloop是什么／runloop的概念？\n\n    >runloop是线程相关的基础框架的一部分。一个runloop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。其实内部就是do－while循环，这个循环内部不断地处理各种任务（比如Source，Timer，Observer）。使用runloop的目的是让你的线程在有工作的时候忙于工作，而没工作的时候处于休眠状态。\n\n14. UITableViewCell上有个UILabel，显示NSTimer实现的秒表时间，手指滚动cell过程中，label是否刷新，为什么？\n\n    >这是否刷新取决于timer加入到Run Loop中的Mode是什么。Mode主要是用来指定事件在运行循环中的优先级的，分为\n    NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态\n    UITrackingRunLoopMode：ScrollView滑动时会切换到该Mode\n    UIInitializationRunLoopMode：run loop启动时，会切换到该mode\n    NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合\n    苹果公开提供的Mode有两个\n    NSDefaultRunLoopMode（kCFRunLoopDefaultMode）\n    NSRunLoopCommonModes（kCFRunLoopCommonModes）\n    在编程中：如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。当我们滚动的时候，也希望不调度，那就应该使用默认模式。但是，如果希望在滚动时，定时器也要回调，那就应该使用common mode。\n    \n15. NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?\n\n    >不准；不准的原因如下\n    1、NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。\n    2、模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。\n    当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个ScrollView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。所以就会影响到NSTimer不准的情况。\n    PS:DefaultMode 是 App 平时所处的状态，rackingRunLoopMode 是追踪 ScrollView 滑动时的状态。\n    方法：\n    1、在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中。避免被复杂运算操作或者UI界面刷新所干扰self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(showTime) userInfo:nil repeats:YES];\n    [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];\n    2、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果\n    \n    ```[object-c]\n    -(void)timerMethod2 {\n        NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];\n        [thread start];\n    }\n    \n    -(void)newThread{\n        @autoreleasepool{\n            [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(showTime) userInfo:nil repeats:YES];\n            [[NSRunLoop currentRunLoop] run];\n        }\n    }\n    ```\n\n16. NSOperation 相比于 GCD 有哪些优势？\n\n    >GCD是基于c的底层api，NSOperation属于object-c类。ios 首先引入的是NSOperation，IOS4之后引入了GCD和NSOperationQueue并且其内部是用gcd实现的。\n    相对于GCD：\n    1、NSOperation拥有更多的函数可用，具体查看api。\n    2、在NSOperationQueue中，可以建立各个NSOperation之间的依赖关系。\n    3、有kvo可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）。\n    4、NSOperationQueue可以方便的管理并发、NSOperation之间的优先级。\n    GCD主要与block结合使用。代码简洁高效。\n    GCD也可以实现复杂的多线程应用，主要是建立个个线程时间的依赖关系这类的情况，但是需要自己实现相比NSOperation要复杂。\n    具体使用哪个，依需求而定。 从个人使用的感觉来看，比较合适的用法是：除了依赖关系尽量使用GCD，因为苹果专门为GCD做了性能上面的优化。\n\n17. 如何访问并修改一个类的私有属性?\n\n    >有两种方法可以访问私有属性,一种是通过KVC获取,一种是通过runtime访问并修改私有属性。\n\n18. 如何捕获异常？\n\n    >1.在app启动时(didFinishLaunchingWithOptions)，添加一个异常捕获的监听\n    NSSetUncaughtExceptionHandler(&UncaughtExceptionHandler);\n    >2.实现捕获异常日志并保存到本地的方法\n    \n    ```[Object-c]\n    void UncaughtExceptionHandler(NSException *exception){\n        //异常日志获取\n        NSArray  *excpArr = [exception callStackSymbols];\n        NSString *reason = [exception reason];\n        NSString *name = [exception name];\n        NSString *excpCnt = [NSString stringWithFormat:@\"exceptionType: %@ \\n reason: %@ \\n stackSymbols: %@\",name,reason,excpArr];\n        //日常日志保存（可以将此功能单独提炼到一个方法中）\n        NSArray  *dirArr  = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\n        NSString *dirPath = dirArr[0];\n        NSString *logDir = [dirPath stringByAppendingString:@\"/CrashLog\"];\n    \n        BOOL isExistLogDir = YES;\n        NSFileManager *fileManager = [NSFileManager defaultManager];\n        if (![fileManager fileExistsAtPath:logDir]) {\n            isExistLogDir = [fileManager createDirectoryAtPath:logDir withIntermediateDirectories:YES attributes:nil error:nil];\n        }\n        if (isExistLogDir) {\n            //此处可扩展\n            NSString *logPath = [logDir stringByAppendingString:@\"/crashLog.txt\"];\n            [excpCnt writeToFile:logPath atomically:YES encoding:NSUTF8StringEncoding error:nil];\n        }\n    }\n    ```\n\n19. Object-c的类可以多重继承么?可以实现多个接口么?Category是什么?重写一个类的方式用继承好还是分类好?为什么?\n\n    >答：Object-c的类不可以多重继承;可以实现多个接口，通过实现多个接口可以完成C++的多重继承;Category是类别，一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。\n\n20. Category(分类)，Extension(扩展)和继承的区别\n    >答：1.分类\n    category原则上只能在现有类基础上添加新的方法（能添加属性的原因只是通过runtime解决无setter/getter的问题而已），类别中的方法没被实现编译器是不会有任何警告的，这是因为类别是在运行时添加到类中的\n    2.扩展\n    iOS中的extension就是匿名的分类，只有头文件没有实现文件。类扩展不仅可以增加方法，还可以增加实例变量（或者属性），只是该实例变量默认是@private类型的（使用范围只能在自身类，而不是子类或其他地方），类扩展中声明的方法没被实现，编译器会报警，这是因为类扩展是在编译阶段被添加到类中的\n    3.继承\n    在iOS中继承是单继承，既只能有一个父类。在继承中，子类可以使用父类的方法和变量，当子类想对本类或者父类的变量进行初始化，那么需要重写init()方法 。父类也可以访问子类的方法和成员变量\n\n21. 简述内存分区情况\n\n    >1). 代码区：存放函数二进制代码\n    2). 数据区：系统运行时申请内存并初始化，系统退出时由系统释放。存放全局变量、静态变量、常量\n    3). 堆区：通过malloc等函数或new等操作符动态申请得到，需程序员手动申请和释放\n    4). 栈区：函数模块内申请，函数结束时由系统自动释放。存放局部变量、函数参数\n\n22. 直接调用_objc_msgForward函数将会发生什么？\n\n    >_objc_msgForward是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。\n    直接调用_objc_msgForward是非常危险的事，如果用不好会直接导致程序Crash，但是如果用得好，能做很多非常酷的事。\n    一旦调用_objc_msgForward，将跳过查找 IMP 的过程，直接触发“消息转发”，如果调用了_objc_msgForward，即使这个对象确实已经实现了这个方法，你也会告诉objc_msgSend：“我没有在这个对象里找到这个方法的实现”\n\n23. 对于Run Loop的理解\n\n    >RunLoop，是多线程的法宝，即一个线程一次只能执行一个任务，执行完任务后就会退出线程。主线程执行完即时任务时会继续等待接收事件而不退出。非主线程通常来说就是为了执行某一任务的，执行完毕就需要归还资源，因此默认是不运行RunLoop的；\n    每一个线程都有其对应的RunLoop，只是默认只有主线程的RunLoop是启动的，其它子线程的RunLoop默认是不启动的，若要启动则需要手动启动；\n    在一个单独的线程中，如果需要在处理完某个任务后不退出，继续等待接收事件，则需要启用RunLoop；\n    NSRunLoop提供了一个添加NSTimer的方法，可以指定Mode，如果要让任何情况下都回调，则需要设置Mode为Common模式；\n    实质上，对于子线程的runloop默认是不存在的，因为苹果采用了懒加载的方式。如果我们没有手动调用[NSRunLoop currentRunLoop]的话，就不会去查询是否存在当前线程的RunLoop，也就不会去加载，更不会创建。\n    \n24. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）\n    \n    >1.每一个类对象中都一个对象方法列表（对象方法缓存）\n    2.类方法列表是存放在类对象中isa指针指向的元类对象中（类方法缓存）\n    3.方法列表中每个方法结构体中记录着方法的名称,方法实现,以及参数类型，其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.\n    4.当我们发送一个消息给一个NSObject对象时，这条消息会在对象的类对象方法列表里查找\n    5.当我们发送一个消息给一个类时，这条消息会在类的Meta Class对象的方法列表里查找\n\n25. runtime 中，SEL 和 IMP 的区别\n\n    >方法名 SEL – 表示该方法的名称；\n    IMP – 指向该方法的具体实现的函数指针，说白了IMP就是实现方法。\n\n26. block底层实现\n\n    >block本质是指向一个结构体的一个指针\n    运行时机制 比较高级的特性 纯C语言\n    平时写的OC代码 转换成C语言运行时的代码\n    指令:clang -rewrite-objc main.m(可以打印验证)\n    默认情况下,任何block都是在栈里面的,随时可能被回收\n    只要对其做一次copy操作 block的内存就会放在堆里面 不会释放\n    只有copy才能产生一个新的内存地址 所有地址会发生改变\n\n27. TCP协议三次握手\n\n    >TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志——SYN(synchronize)和ACK(acknowledgement)。发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。\n\n28. @property 的本质是什么？\n\n    >@property = ivar + getter + setter;\n    “属性” (property)有两大概念：ivar（实例变量）、getter+setter（存取方法）\n\n29. KVC的底层实现？\n\n    >当一个对象调用setValue方法时，方法内部会做以下操作：\n    1). 检查是否存在相应的key的set方法，如果存在，就调用set方法。\n    2). 如果set方法不存在，就会查找与key相同名称并且带下划线的成员变量，如果有，则直接给成员变量属性赋值。\n    3). 如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值。\n    4). 如果还没有找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法。\n    这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。\n\n30. ViewController生命周期\n\n    >按照执行顺序排列：\n    1). initWithCoder：通过nib文件初始化时触发。\n    2). awakeFromNib：nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每个对象。\n    3). loadView：开始加载视图控制器自带的view。\n    4). viewDidLoad：视图控制器的view被加载完成。\n    5). viewWillAppear：视图控制器的view将要显示在window上。\n    6). updateViewConstraints：视图控制器的view开始更新AutoLayout约束。\n    7). viewWillLayoutSubviews：视图控制器的view将要更新内容视图的位置。\n    8). viewDidLayoutSubviews：视图控制器的view已经更新视图的位置。\n    9). viewDidAppear：视图控制器的view已经展示到window上。\n    10). viewWillDisappear：视图控制器的view将要从window上消失。\n    11). viewDidDisappear：视图控制器的view已经从window上消失。\n\n31. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\n\n    >// 使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。\n    // 创建队列组\n    dispatch_group_t group = dispatch_group_create();\n    // 获取全局并发队列\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    dispatch_group_async(group, queue, ^{ /*加载图片1 */ });\n    dispatch_group_async(group, queue, ^{ /*加载图片2 */ });\n    dispatch_group_async(group, queue, ^{ /*加载图片3 */ }); \n    // 当并发队列组中的任务执行完毕后才会执行这里的代码\n    dispatch_group_notify(group, dispatch_get_main_queue(), ^{\n    // 合并图片\n    });\n\n32. dispatch_barrier_async（栅栏函数）的作用是什么？\n\n    >函数定义：dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);\n    作用：\n    1.在它前面的任务执行结束后它才执行，它后面的任务要等它执行完成后才会开始执行。\n    2.避免数据竞争\n    \n    ```[object-c]\n    // 1.创建并发队列\n    dispatch_queue_t queue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_CONCURRENT);\n    // 2.向队列中添加任务\n    dispatch_async(queue, ^{  // 1.2是并行的\n        NSLog(@\"任务1, %@\",[NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"任务2, %@\",[NSThread currentThread]);\n    });\n    \n    >dispatch_barrier_async(queue, ^{\n        NSLog(@\"任务 barrier, %@\", [NSThread currentThread]);\n    });\n    \n    >dispatch_async(queue, ^{   // 这两个是同时执行的\n        NSLog(@\"任务3, %@\",[NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"任务4, %@\",[NSThread currentThread]);\n    });\n    \n    // 输出结果: 任务1 任务2 ——》 任务 barrier ——》任务3 任务4 \n    // 其中的任务1与任务2，任务3与任务4 由于是并行处理先后顺序不定。\n    ```\n","source":"_posts/iOS-面试题汇总.md","raw":"---\ntitle: iOS 面试题汇总\ndate: 2019-10-10 10:46:19\ntags:\n---\n\n\n原文链接：https://blog.csdn.net/gsl111000/article/details/93629640\n\n1. 简单介绍下 NSURLConnection 类及+ sendSynchronousRequest:returningResponse:error:与– initWithRequest:delegate:两个方法的区别?\n\n    >答: NSURLConnection主要用于网络访问，其中+ sendSynchronousRequest:returningResponse:error:是同步访问数据，即当前线程会阻塞，并等待request的返回的response，而– initWithRequest:delegate:使用的是异步加载，当其完成网络访问后，会通过delegate回到主线程，并其委托的对象。\n\n2. 在项目什么时候选择使用GCD，什么时候选择NSOperation\n\n    >答: 项目中使用NSOperation的优点是NSOperation是对线程的高度抽象，在项目中使用它，会使项目的程序结构更好，子类化NSOperation的设计思路，是具有面向对象的优点(复用、封装)，使得实现是多线程支持，而接口简单，建议在复杂项目中使用。\n    项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线程操作，会节省代码量，而Block参数的使用，会是代码更为易读，建议在简单项目中使用。\n\n3. ViewController的didReceiveMemoryWarning怎么被调用\n\n    >答:[supper didReceiveMemoryWarning];\n\n4. 写一个setter方法用于完成@property(nonatomic, retain) NSString *name,写一个setter方法用于完成@property(nonatomic, copy) NSString *name\n\n    ```[object-c]\n    - (void)setName:(NSString *)str{\n        [str retain];\n        [_name release];\n        _name = str;\n    }\n    - (void)setName:(NSString *)str{\n        id t = [str copy];\n        [_name release];\n        _name = t;\n    }\n    ```\n\n5. 对于语句NSString *obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?\n\n    >答： 编译时是NSString的类型;运行时是NSData类型的对象\n\n6. Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?\n\n    >答：线程创建有三种方法：使用NSThread创建、使用GCD的dispatch、使用子类化的NSOperation,然后将其加入NSOperationQueue;在主线程执行代码，方法是performSelectorOnMainThread，如果想延时执行代码可以用performSelector:onThread:withObject:waitUntilDone:\n\n7. 浅复制和深复制的区别?\n\n    >答：浅层复制：只复制指向对象的指针，而不复制引用对象本身。\n深层复制：复制引用对象本身。\n\n8. PerformSelecter\n\n    >当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。\n当调用performSelector:onThread:时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。\n\n9. 优化你是从哪几方面着手？\n\n    >一、首页启动速度\n    启动过程中做的事情越少越好（尽可能将多个接口合并）\n    不在UI线程上作耗时的操作（数据的处理在子线程进行，处理完通知主线程刷新节目）\n    在合适的时机开始后台任务（例如在用户指引节目就可以开始准备加载的数据）\n    二、页面浏览速度\n    json的处理（iOS 自带的NSJSONSerialization，Jsonkit，SBJson）\n    数据的分页（后端数据多的话，就要分页返回，例如网易新闻，或者 微博记录）\n    数据压缩（大数据也可以压缩返回，减少流量，加快反应速度）\n    内容缓存（例如网易新闻的最新新闻列表都是要缓存到本地，从本地加载，可以缓存到内存，或者数据库，根据情况而定）\n    延时加载tab（比如app有5个tab，可以先加载第一个要显示的tab，其他的在显示时候加载，按需加载）\n    算法的优化（核心算法的优化，例如有些app 有个 联系人姓名用汉语拼音的首字母排序）\n    三、操作流畅度优化\n    Tableview 优化（tableview cell的加载优化）\n    ViewController加载优化（不同view之间的跳转，可以提前准备好数据）\n    四、数据库的优化\n    数据库设计上面的重构\n    查询语句的优化\n    分库分表（数据太多的时候，可以分不同的表或者库）\n    五、服务器端和客户端的交互优化\n    客户端尽量减少请求\n    服务端尽量做多的逻辑处理\n    服务器端和客户端采取推拉结合的方式（可以利用一些同步机制）\n    通信协议的优化（减少报文的大小）\n    电量使用优化（尽量不要使用后台运行）\n    六、非技术性能优化\n    产品设计的逻辑性（产品的设计一定要符合逻辑，或者逻辑尽量简单，否则会让程序员抓狂，有时候用了好大力气，才可以完成一个小小的逻辑设计问题）\n    界面交互的规范（每个模块的界面的交互尽量统一，符合操作习惯）\n    代码规范（这个可以隐形带来app 性能的提高，比如 用if else 还是switch ，或者是用！还是 ＝＝）\n    code review（坚持code Review 持续重构代码。减少代码的逻辑复杂度）\n\n10. 什么情况使用 weak 关键字，相比 assign 有什么不同？\n\n    >1.在ARC中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性。\n    2.自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,如自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。\n    IBOutlet连出来的视图属性为什么可以被设置成weak?\n    答：因为父控件的subViews数组已经对它有一个强引用。\n    不同点\n    assign 可以用非 OC 对象，而 weak 必须用于 OC 对象。\n    weak 表明该属性定义了一种“非拥有关系”。在属性所指的对象销毁时，属性值会自动清空(nil)\n\n11. 用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？\n\n    >答：用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的），为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。\n    1.因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。\n    2.如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。\n    总结：使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发送变化会无意间篡改不可变类型对象原来的值。\n\n12. runtime如何实现weak变量的自动置nil？\n\n    >runtime对注册的类，会进行布局，会将 weak 对象放入一个 hash 表中。用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会调用对象的 dealloc 方法，假设 weak 指向的对象内存地址是a，那么就会以a为key，在这个 weak hash表中搜索，找到所有以a为key的 weak 对象，从而设置为nil\n\n13. runloop是什么／runloop的概念？\n\n    >runloop是线程相关的基础框架的一部分。一个runloop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。其实内部就是do－while循环，这个循环内部不断地处理各种任务（比如Source，Timer，Observer）。使用runloop的目的是让你的线程在有工作的时候忙于工作，而没工作的时候处于休眠状态。\n\n14. UITableViewCell上有个UILabel，显示NSTimer实现的秒表时间，手指滚动cell过程中，label是否刷新，为什么？\n\n    >这是否刷新取决于timer加入到Run Loop中的Mode是什么。Mode主要是用来指定事件在运行循环中的优先级的，分为\n    NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态\n    UITrackingRunLoopMode：ScrollView滑动时会切换到该Mode\n    UIInitializationRunLoopMode：run loop启动时，会切换到该mode\n    NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合\n    苹果公开提供的Mode有两个\n    NSDefaultRunLoopMode（kCFRunLoopDefaultMode）\n    NSRunLoopCommonModes（kCFRunLoopCommonModes）\n    在编程中：如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。当我们滚动的时候，也希望不调度，那就应该使用默认模式。但是，如果希望在滚动时，定时器也要回调，那就应该使用common mode。\n    \n15. NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?\n\n    >不准；不准的原因如下\n    1、NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。\n    2、模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。\n    当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个ScrollView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。所以就会影响到NSTimer不准的情况。\n    PS:DefaultMode 是 App 平时所处的状态，rackingRunLoopMode 是追踪 ScrollView 滑动时的状态。\n    方法：\n    1、在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中。避免被复杂运算操作或者UI界面刷新所干扰self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(showTime) userInfo:nil repeats:YES];\n    [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];\n    2、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果\n    \n    ```[object-c]\n    -(void)timerMethod2 {\n        NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];\n        [thread start];\n    }\n    \n    -(void)newThread{\n        @autoreleasepool{\n            [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(showTime) userInfo:nil repeats:YES];\n            [[NSRunLoop currentRunLoop] run];\n        }\n    }\n    ```\n\n16. NSOperation 相比于 GCD 有哪些优势？\n\n    >GCD是基于c的底层api，NSOperation属于object-c类。ios 首先引入的是NSOperation，IOS4之后引入了GCD和NSOperationQueue并且其内部是用gcd实现的。\n    相对于GCD：\n    1、NSOperation拥有更多的函数可用，具体查看api。\n    2、在NSOperationQueue中，可以建立各个NSOperation之间的依赖关系。\n    3、有kvo可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）。\n    4、NSOperationQueue可以方便的管理并发、NSOperation之间的优先级。\n    GCD主要与block结合使用。代码简洁高效。\n    GCD也可以实现复杂的多线程应用，主要是建立个个线程时间的依赖关系这类的情况，但是需要自己实现相比NSOperation要复杂。\n    具体使用哪个，依需求而定。 从个人使用的感觉来看，比较合适的用法是：除了依赖关系尽量使用GCD，因为苹果专门为GCD做了性能上面的优化。\n\n17. 如何访问并修改一个类的私有属性?\n\n    >有两种方法可以访问私有属性,一种是通过KVC获取,一种是通过runtime访问并修改私有属性。\n\n18. 如何捕获异常？\n\n    >1.在app启动时(didFinishLaunchingWithOptions)，添加一个异常捕获的监听\n    NSSetUncaughtExceptionHandler(&UncaughtExceptionHandler);\n    >2.实现捕获异常日志并保存到本地的方法\n    \n    ```[Object-c]\n    void UncaughtExceptionHandler(NSException *exception){\n        //异常日志获取\n        NSArray  *excpArr = [exception callStackSymbols];\n        NSString *reason = [exception reason];\n        NSString *name = [exception name];\n        NSString *excpCnt = [NSString stringWithFormat:@\"exceptionType: %@ \\n reason: %@ \\n stackSymbols: %@\",name,reason,excpArr];\n        //日常日志保存（可以将此功能单独提炼到一个方法中）\n        NSArray  *dirArr  = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\n        NSString *dirPath = dirArr[0];\n        NSString *logDir = [dirPath stringByAppendingString:@\"/CrashLog\"];\n    \n        BOOL isExistLogDir = YES;\n        NSFileManager *fileManager = [NSFileManager defaultManager];\n        if (![fileManager fileExistsAtPath:logDir]) {\n            isExistLogDir = [fileManager createDirectoryAtPath:logDir withIntermediateDirectories:YES attributes:nil error:nil];\n        }\n        if (isExistLogDir) {\n            //此处可扩展\n            NSString *logPath = [logDir stringByAppendingString:@\"/crashLog.txt\"];\n            [excpCnt writeToFile:logPath atomically:YES encoding:NSUTF8StringEncoding error:nil];\n        }\n    }\n    ```\n\n19. Object-c的类可以多重继承么?可以实现多个接口么?Category是什么?重写一个类的方式用继承好还是分类好?为什么?\n\n    >答：Object-c的类不可以多重继承;可以实现多个接口，通过实现多个接口可以完成C++的多重继承;Category是类别，一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。\n\n20. Category(分类)，Extension(扩展)和继承的区别\n    >答：1.分类\n    category原则上只能在现有类基础上添加新的方法（能添加属性的原因只是通过runtime解决无setter/getter的问题而已），类别中的方法没被实现编译器是不会有任何警告的，这是因为类别是在运行时添加到类中的\n    2.扩展\n    iOS中的extension就是匿名的分类，只有头文件没有实现文件。类扩展不仅可以增加方法，还可以增加实例变量（或者属性），只是该实例变量默认是@private类型的（使用范围只能在自身类，而不是子类或其他地方），类扩展中声明的方法没被实现，编译器会报警，这是因为类扩展是在编译阶段被添加到类中的\n    3.继承\n    在iOS中继承是单继承，既只能有一个父类。在继承中，子类可以使用父类的方法和变量，当子类想对本类或者父类的变量进行初始化，那么需要重写init()方法 。父类也可以访问子类的方法和成员变量\n\n21. 简述内存分区情况\n\n    >1). 代码区：存放函数二进制代码\n    2). 数据区：系统运行时申请内存并初始化，系统退出时由系统释放。存放全局变量、静态变量、常量\n    3). 堆区：通过malloc等函数或new等操作符动态申请得到，需程序员手动申请和释放\n    4). 栈区：函数模块内申请，函数结束时由系统自动释放。存放局部变量、函数参数\n\n22. 直接调用_objc_msgForward函数将会发生什么？\n\n    >_objc_msgForward是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。\n    直接调用_objc_msgForward是非常危险的事，如果用不好会直接导致程序Crash，但是如果用得好，能做很多非常酷的事。\n    一旦调用_objc_msgForward，将跳过查找 IMP 的过程，直接触发“消息转发”，如果调用了_objc_msgForward，即使这个对象确实已经实现了这个方法，你也会告诉objc_msgSend：“我没有在这个对象里找到这个方法的实现”\n\n23. 对于Run Loop的理解\n\n    >RunLoop，是多线程的法宝，即一个线程一次只能执行一个任务，执行完任务后就会退出线程。主线程执行完即时任务时会继续等待接收事件而不退出。非主线程通常来说就是为了执行某一任务的，执行完毕就需要归还资源，因此默认是不运行RunLoop的；\n    每一个线程都有其对应的RunLoop，只是默认只有主线程的RunLoop是启动的，其它子线程的RunLoop默认是不启动的，若要启动则需要手动启动；\n    在一个单独的线程中，如果需要在处理完某个任务后不退出，继续等待接收事件，则需要启用RunLoop；\n    NSRunLoop提供了一个添加NSTimer的方法，可以指定Mode，如果要让任何情况下都回调，则需要设置Mode为Common模式；\n    实质上，对于子线程的runloop默认是不存在的，因为苹果采用了懒加载的方式。如果我们没有手动调用[NSRunLoop currentRunLoop]的话，就不会去查询是否存在当前线程的RunLoop，也就不会去加载，更不会创建。\n    \n24. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）\n    \n    >1.每一个类对象中都一个对象方法列表（对象方法缓存）\n    2.类方法列表是存放在类对象中isa指针指向的元类对象中（类方法缓存）\n    3.方法列表中每个方法结构体中记录着方法的名称,方法实现,以及参数类型，其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.\n    4.当我们发送一个消息给一个NSObject对象时，这条消息会在对象的类对象方法列表里查找\n    5.当我们发送一个消息给一个类时，这条消息会在类的Meta Class对象的方法列表里查找\n\n25. runtime 中，SEL 和 IMP 的区别\n\n    >方法名 SEL – 表示该方法的名称；\n    IMP – 指向该方法的具体实现的函数指针，说白了IMP就是实现方法。\n\n26. block底层实现\n\n    >block本质是指向一个结构体的一个指针\n    运行时机制 比较高级的特性 纯C语言\n    平时写的OC代码 转换成C语言运行时的代码\n    指令:clang -rewrite-objc main.m(可以打印验证)\n    默认情况下,任何block都是在栈里面的,随时可能被回收\n    只要对其做一次copy操作 block的内存就会放在堆里面 不会释放\n    只有copy才能产生一个新的内存地址 所有地址会发生改变\n\n27. TCP协议三次握手\n\n    >TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志——SYN(synchronize)和ACK(acknowledgement)。发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。\n\n28. @property 的本质是什么？\n\n    >@property = ivar + getter + setter;\n    “属性” (property)有两大概念：ivar（实例变量）、getter+setter（存取方法）\n\n29. KVC的底层实现？\n\n    >当一个对象调用setValue方法时，方法内部会做以下操作：\n    1). 检查是否存在相应的key的set方法，如果存在，就调用set方法。\n    2). 如果set方法不存在，就会查找与key相同名称并且带下划线的成员变量，如果有，则直接给成员变量属性赋值。\n    3). 如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值。\n    4). 如果还没有找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法。\n    这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。\n\n30. ViewController生命周期\n\n    >按照执行顺序排列：\n    1). initWithCoder：通过nib文件初始化时触发。\n    2). awakeFromNib：nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每个对象。\n    3). loadView：开始加载视图控制器自带的view。\n    4). viewDidLoad：视图控制器的view被加载完成。\n    5). viewWillAppear：视图控制器的view将要显示在window上。\n    6). updateViewConstraints：视图控制器的view开始更新AutoLayout约束。\n    7). viewWillLayoutSubviews：视图控制器的view将要更新内容视图的位置。\n    8). viewDidLayoutSubviews：视图控制器的view已经更新视图的位置。\n    9). viewDidAppear：视图控制器的view已经展示到window上。\n    10). viewWillDisappear：视图控制器的view将要从window上消失。\n    11). viewDidDisappear：视图控制器的view已经从window上消失。\n\n31. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）\n\n    >// 使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。\n    // 创建队列组\n    dispatch_group_t group = dispatch_group_create();\n    // 获取全局并发队列\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    dispatch_group_async(group, queue, ^{ /*加载图片1 */ });\n    dispatch_group_async(group, queue, ^{ /*加载图片2 */ });\n    dispatch_group_async(group, queue, ^{ /*加载图片3 */ }); \n    // 当并发队列组中的任务执行完毕后才会执行这里的代码\n    dispatch_group_notify(group, dispatch_get_main_queue(), ^{\n    // 合并图片\n    });\n\n32. dispatch_barrier_async（栅栏函数）的作用是什么？\n\n    >函数定义：dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);\n    作用：\n    1.在它前面的任务执行结束后它才执行，它后面的任务要等它执行完成后才会开始执行。\n    2.避免数据竞争\n    \n    ```[object-c]\n    // 1.创建并发队列\n    dispatch_queue_t queue = dispatch_queue_create(\"myQueue\", DISPATCH_QUEUE_CONCURRENT);\n    // 2.向队列中添加任务\n    dispatch_async(queue, ^{  // 1.2是并行的\n        NSLog(@\"任务1, %@\",[NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"任务2, %@\",[NSThread currentThread]);\n    });\n    \n    >dispatch_barrier_async(queue, ^{\n        NSLog(@\"任务 barrier, %@\", [NSThread currentThread]);\n    });\n    \n    >dispatch_async(queue, ^{   // 这两个是同时执行的\n        NSLog(@\"任务3, %@\",[NSThread currentThread]);\n    });\n    dispatch_async(queue, ^{\n        NSLog(@\"任务4, %@\",[NSThread currentThread]);\n    });\n    \n    // 输出结果: 任务1 任务2 ——》 任务 barrier ——》任务3 任务4 \n    // 其中的任务1与任务2，任务3与任务4 由于是并行处理先后顺序不定。\n    ```\n","slug":"iOS-面试题汇总","published":1,"updated":"2019-10-10T03:35:54.909Z","_id":"ck1k3opl50000pi6yhl4f5iw9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>原文链接：<a href=\"https://blog.csdn.net/gsl111000/article/details/93629640\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/gsl111000/article/details/93629640</a></p>\n<ol>\n<li><p>简单介绍下 NSURLConnection 类及+ sendSynchronousRequest:returningResponse:error:与– initWithRequest:delegate:两个方法的区别?</p>\n<blockquote>\n<p>答: NSURLConnection主要用于网络访问，其中+ sendSynchronousRequest:returningResponse:error:是同步访问数据，即当前线程会阻塞，并等待request的返回的response，而– initWithRequest:delegate:使用的是异步加载，当其完成网络访问后，会通过delegate回到主线程，并其委托的对象。</p>\n</blockquote>\n</li>\n<li><p>在项目什么时候选择使用GCD，什么时候选择NSOperation</p>\n<blockquote>\n<p>答: 项目中使用NSOperation的优点是NSOperation是对线程的高度抽象，在项目中使用它，会使项目的程序结构更好，子类化NSOperation的设计思路，是具有面向对象的优点(复用、封装)，使得实现是多线程支持，而接口简单，建议在复杂项目中使用。<br> 项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线程操作，会节省代码量，而Block参数的使用，会是代码更为易读，建议在简单项目中使用。</p>\n</blockquote>\n</li>\n<li><p>ViewController的didReceiveMemoryWarning怎么被调用</p>\n<blockquote>\n<p>答:[supper didReceiveMemoryWarning];</p>\n</blockquote>\n</li>\n<li><p>写一个setter方法用于完成@property(nonatomic, retain) NSString <em>name,写一个setter方法用于完成@property(nonatomic, copy) NSString </em>name</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setName:(NSString *)str&#123;</span><br><span class=\"line\">    [str retain];</span><br><span class=\"line\">    [_name release];</span><br><span class=\"line\">    _name = str;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)setName:(NSString *)str&#123;</span><br><span class=\"line\">    id t = [str copy];</span><br><span class=\"line\">    [_name release];</span><br><span class=\"line\">    _name = t;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对于语句NSString *obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?</p>\n<blockquote>\n<p>答： 编译时是NSString的类型;运行时是NSData类型的对象</p>\n</blockquote>\n</li>\n<li><p>Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?</p>\n<blockquote>\n<p>答：线程创建有三种方法：使用NSThread创建、使用GCD的dispatch、使用子类化的NSOperation,然后将其加入NSOperationQueue;在主线程执行代码，方法是performSelectorOnMainThread，如果想延时执行代码可以用performSelector:onThread:withObject:waitUntilDone:</p>\n</blockquote>\n</li>\n<li><p>浅复制和深复制的区别?</p>\n<blockquote>\n<p>答：浅层复制：只复制指向对象的指针，而不复制引用对象本身。<br>深层复制：复制引用对象本身。</p>\n</blockquote>\n</li>\n<li><p>PerformSelecter</p>\n<blockquote>\n<p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。<br>当调用performSelector:onThread:时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>\n</blockquote>\n</li>\n<li><p>优化你是从哪几方面着手？</p>\n<blockquote>\n<p>一、首页启动速度<br> 启动过程中做的事情越少越好（尽可能将多个接口合并）<br> 不在UI线程上作耗时的操作（数据的处理在子线程进行，处理完通知主线程刷新节目）<br> 在合适的时机开始后台任务（例如在用户指引节目就可以开始准备加载的数据）<br> 二、页面浏览速度<br> json的处理（iOS 自带的NSJSONSerialization，Jsonkit，SBJson）<br> 数据的分页（后端数据多的话，就要分页返回，例如网易新闻，或者 微博记录）<br> 数据压缩（大数据也可以压缩返回，减少流量，加快反应速度）<br> 内容缓存（例如网易新闻的最新新闻列表都是要缓存到本地，从本地加载，可以缓存到内存，或者数据库，根据情况而定）<br> 延时加载tab（比如app有5个tab，可以先加载第一个要显示的tab，其他的在显示时候加载，按需加载）<br> 算法的优化（核心算法的优化，例如有些app 有个 联系人姓名用汉语拼音的首字母排序）<br> 三、操作流畅度优化<br> Tableview 优化（tableview cell的加载优化）<br> ViewController加载优化（不同view之间的跳转，可以提前准备好数据）<br> 四、数据库的优化<br> 数据库设计上面的重构<br> 查询语句的优化<br> 分库分表（数据太多的时候，可以分不同的表或者库）<br> 五、服务器端和客户端的交互优化<br> 客户端尽量减少请求<br> 服务端尽量做多的逻辑处理<br> 服务器端和客户端采取推拉结合的方式（可以利用一些同步机制）<br> 通信协议的优化（减少报文的大小）<br> 电量使用优化（尽量不要使用后台运行）<br> 六、非技术性能优化<br> 产品设计的逻辑性（产品的设计一定要符合逻辑，或者逻辑尽量简单，否则会让程序员抓狂，有时候用了好大力气，才可以完成一个小小的逻辑设计问题）<br> 界面交互的规范（每个模块的界面的交互尽量统一，符合操作习惯）<br> 代码规范（这个可以隐形带来app 性能的提高，比如 用if else 还是switch ，或者是用！还是 ＝＝）<br> code review（坚持code Review 持续重构代码。减少代码的逻辑复杂度）</p>\n</blockquote>\n</li>\n<li><p>什么情况使用 weak 关键字，相比 assign 有什么不同？</p>\n<blockquote>\n<p>1.在ARC中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性。<br>2.自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,如自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。<br>IBOutlet连出来的视图属性为什么可以被设置成weak?<br>答：因为父控件的subViews数组已经对它有一个强引用。<br>不同点<br>assign 可以用非 OC 对象，而 weak 必须用于 OC 对象。<br>weak 表明该属性定义了一种“非拥有关系”。在属性所指的对象销毁时，属性值会自动清空(nil)</p>\n</blockquote>\n</li>\n<li><p>用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？</p>\n<blockquote>\n<p>答：用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的），为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。<br>1.因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。<br>2.如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。<br>总结：使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发送变化会无意间篡改不可变类型对象原来的值。</p>\n</blockquote>\n</li>\n<li><p>runtime如何实现weak变量的自动置nil？</p>\n<blockquote>\n<p>runtime对注册的类，会进行布局，会将 weak 对象放入一个 hash 表中。用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会调用对象的 dealloc 方法，假设 weak 指向的对象内存地址是a，那么就会以a为key，在这个 weak hash表中搜索，找到所有以a为key的 weak 对象，从而设置为nil</p>\n</blockquote>\n</li>\n<li><p>runloop是什么／runloop的概念？</p>\n<blockquote>\n<p>runloop是线程相关的基础框架的一部分。一个runloop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。其实内部就是do－while循环，这个循环内部不断地处理各种任务（比如Source，Timer，Observer）。使用runloop的目的是让你的线程在有工作的时候忙于工作，而没工作的时候处于休眠状态。</p>\n</blockquote>\n</li>\n<li><p>UITableViewCell上有个UILabel，显示NSTimer实现的秒表时间，手指滚动cell过程中，label是否刷新，为什么？</p>\n<blockquote>\n<p>这是否刷新取决于timer加入到Run Loop中的Mode是什么。Mode主要是用来指定事件在运行循环中的优先级的，分为<br>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态<br>UITrackingRunLoopMode：ScrollView滑动时会切换到该Mode<br>UIInitializationRunLoopMode：run loop启动时，会切换到该mode<br>NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合<br>苹果公开提供的Mode有两个<br>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）<br>NSRunLoopCommonModes（kCFRunLoopCommonModes）<br>在编程中：如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。当我们滚动的时候，也希望不调度，那就应该使用默认模式。但是，如果希望在滚动时，定时器也要回调，那就应该使用common mode。</p>\n</blockquote>\n</li>\n<li><p>NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?</p>\n<blockquote>\n<p>不准；不准的原因如下<br>1、NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。<br>2、模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。<br>当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个ScrollView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。所以就会影响到NSTimer不准的情况。<br>PS:DefaultMode 是 App 平时所处的状态，rackingRunLoopMode 是追踪 ScrollView 滑动时的状态。<br>方法：<br>1、在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中。避免被复杂运算操作或者UI界面刷新所干扰self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(showTime) userInfo:nil repeats:YES];<br>[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];<br>2、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(void)timerMethod2 &#123;</span><br><span class=\"line\">    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];</span><br><span class=\"line\">    [thread start];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">-(void)newThread&#123;</span><br><span class=\"line\">    @autoreleasepool&#123;</span><br><span class=\"line\">        [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(showTime) userInfo:nil repeats:YES];</span><br><span class=\"line\">        [[NSRunLoop currentRunLoop] run];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>NSOperation 相比于 GCD 有哪些优势？</p>\n<blockquote>\n<p>GCD是基于c的底层api，NSOperation属于object-c类。ios 首先引入的是NSOperation，IOS4之后引入了GCD和NSOperationQueue并且其内部是用gcd实现的。<br>相对于GCD：<br>1、NSOperation拥有更多的函数可用，具体查看api。<br>2、在NSOperationQueue中，可以建立各个NSOperation之间的依赖关系。<br>3、有kvo可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）。<br>4、NSOperationQueue可以方便的管理并发、NSOperation之间的优先级。<br>GCD主要与block结合使用。代码简洁高效。<br>GCD也可以实现复杂的多线程应用，主要是建立个个线程时间的依赖关系这类的情况，但是需要自己实现相比NSOperation要复杂。<br>具体使用哪个，依需求而定。 从个人使用的感觉来看，比较合适的用法是：除了依赖关系尽量使用GCD，因为苹果专门为GCD做了性能上面的优化。</p>\n</blockquote>\n</li>\n<li><p>如何访问并修改一个类的私有属性?</p>\n<blockquote>\n<p>有两种方法可以访问私有属性,一种是通过KVC获取,一种是通过runtime访问并修改私有属性。</p>\n</blockquote>\n</li>\n<li><p>如何捕获异常？</p>\n<blockquote>\n<p>1.在app启动时(didFinishLaunchingWithOptions)，添加一个异常捕获的监听<br>NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);<br>2.实现捕获异常日志并保存到本地的方法</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void UncaughtExceptionHandler(NSException *exception)&#123;</span><br><span class=\"line\">    //异常日志获取</span><br><span class=\"line\">    NSArray  *excpArr = [exception callStackSymbols];</span><br><span class=\"line\">    NSString *reason = [exception reason];</span><br><span class=\"line\">    NSString *name = [exception name];</span><br><span class=\"line\">    NSString *excpCnt = [NSString stringWithFormat:@&quot;exceptionType: %@ \\n reason: %@ \\n stackSymbols: %@&quot;,name,reason,excpArr];</span><br><span class=\"line\">    //日常日志保存（可以将此功能单独提炼到一个方法中）</span><br><span class=\"line\">    NSArray  *dirArr  = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class=\"line\">    NSString *dirPath = dirArr[0];</span><br><span class=\"line\">    NSString *logDir = [dirPath stringByAppendingString:@&quot;/CrashLog&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">    BOOL isExistLogDir = YES;</span><br><span class=\"line\">    NSFileManager *fileManager = [NSFileManager defaultManager];</span><br><span class=\"line\">    if (![fileManager fileExistsAtPath:logDir]) &#123;</span><br><span class=\"line\">        isExistLogDir = [fileManager createDirectoryAtPath:logDir withIntermediateDirectories:YES attributes:nil error:nil];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (isExistLogDir) &#123;</span><br><span class=\"line\">        //此处可扩展</span><br><span class=\"line\">        NSString *logPath = [logDir stringByAppendingString:@&quot;/crashLog.txt&quot;];</span><br><span class=\"line\">        [excpCnt writeToFile:logPath atomically:YES encoding:NSUTF8StringEncoding error:nil];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Object-c的类可以多重继承么?可以实现多个接口么?Category是什么?重写一个类的方式用继承好还是分类好?为什么?</p>\n<blockquote>\n<p>答：Object-c的类不可以多重继承;可以实现多个接口，通过实现多个接口可以完成C++的多重继承;Category是类别，一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。</p>\n</blockquote>\n</li>\n<li><p>Category(分类)，Extension(扩展)和继承的区别</p>\n<blockquote>\n<p>答：1.分类<br>category原则上只能在现有类基础上添加新的方法（能添加属性的原因只是通过runtime解决无setter/getter的问题而已），类别中的方法没被实现编译器是不会有任何警告的，这是因为类别是在运行时添加到类中的<br>2.扩展<br>iOS中的extension就是匿名的分类，只有头文件没有实现文件。类扩展不仅可以增加方法，还可以增加实例变量（或者属性），只是该实例变量默认是@private类型的（使用范围只能在自身类，而不是子类或其他地方），类扩展中声明的方法没被实现，编译器会报警，这是因为类扩展是在编译阶段被添加到类中的<br>3.继承<br>在iOS中继承是单继承，既只能有一个父类。在继承中，子类可以使用父类的方法和变量，当子类想对本类或者父类的变量进行初始化，那么需要重写init()方法 。父类也可以访问子类的方法和成员变量</p>\n</blockquote>\n</li>\n<li><p>简述内存分区情况</p>\n<blockquote>\n<p>1). 代码区：存放函数二进制代码<br>2). 数据区：系统运行时申请内存并初始化，系统退出时由系统释放。存放全局变量、静态变量、常量<br>3). 堆区：通过malloc等函数或new等操作符动态申请得到，需程序员手动申请和释放<br>4). 栈区：函数模块内申请，函数结束时由系统自动释放。存放局部变量、函数参数</p>\n</blockquote>\n</li>\n<li><p>直接调用_objc_msgForward函数将会发生什么？</p>\n<blockquote>\n<p>_objc_msgForward是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。<br>直接调用_objc_msgForward是非常危险的事，如果用不好会直接导致程序Crash，但是如果用得好，能做很多非常酷的事。<br>一旦调用_objc_msgForward，将跳过查找 IMP 的过程，直接触发“消息转发”，如果调用了_objc_msgForward，即使这个对象确实已经实现了这个方法，你也会告诉objc_msgSend：“我没有在这个对象里找到这个方法的实现”</p>\n</blockquote>\n</li>\n<li><p>对于Run Loop的理解</p>\n<blockquote>\n<p>RunLoop，是多线程的法宝，即一个线程一次只能执行一个任务，执行完任务后就会退出线程。主线程执行完即时任务时会继续等待接收事件而不退出。非主线程通常来说就是为了执行某一任务的，执行完毕就需要归还资源，因此默认是不运行RunLoop的；<br>每一个线程都有其对应的RunLoop，只是默认只有主线程的RunLoop是启动的，其它子线程的RunLoop默认是不启动的，若要启动则需要手动启动；<br>在一个单独的线程中，如果需要在处理完某个任务后不退出，继续等待接收事件，则需要启用RunLoop；<br>NSRunLoop提供了一个添加NSTimer的方法，可以指定Mode，如果要让任何情况下都回调，则需要设置Mode为Common模式；<br>实质上，对于子线程的runloop默认是不存在的，因为苹果采用了懒加载的方式。如果我们没有手动调用[NSRunLoop currentRunLoop]的话，就不会去查询是否存在当前线程的RunLoop，也就不会去加载，更不会创建。</p>\n</blockquote>\n</li>\n<li><p>runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</p>\n<blockquote>\n<p>1.每一个类对象中都一个对象方法列表（对象方法缓存）<br>2.类方法列表是存放在类对象中isa指针指向的元类对象中（类方法缓存）<br>3.方法列表中每个方法结构体中记录着方法的名称,方法实现,以及参数类型，其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.<br>4.当我们发送一个消息给一个NSObject对象时，这条消息会在对象的类对象方法列表里查找<br>5.当我们发送一个消息给一个类时，这条消息会在类的Meta Class对象的方法列表里查找</p>\n</blockquote>\n</li>\n<li><p>runtime 中，SEL 和 IMP 的区别</p>\n<blockquote>\n<p>方法名 SEL – 表示该方法的名称；<br>IMP – 指向该方法的具体实现的函数指针，说白了IMP就是实现方法。</p>\n</blockquote>\n</li>\n<li><p>block底层实现</p>\n<blockquote>\n<p>block本质是指向一个结构体的一个指针<br>运行时机制 比较高级的特性 纯C语言<br>平时写的OC代码 转换成C语言运行时的代码<br>指令:clang -rewrite-objc main.m(可以打印验证)<br>默认情况下,任何block都是在栈里面的,随时可能被回收<br>只要对其做一次copy操作 block的内存就会放在堆里面 不会释放<br>只有copy才能产生一个新的内存地址 所有地址会发生改变</p>\n</blockquote>\n</li>\n<li><p>TCP协议三次握手</p>\n<blockquote>\n<p>TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志——SYN(synchronize)和ACK(acknowledgement)。发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。</p>\n</blockquote>\n</li>\n<li><p>@property 的本质是什么？</p>\n<blockquote>\n<p>@property = ivar + getter + setter;<br>“属性” (property)有两大概念：ivar（实例变量）、getter+setter（存取方法）</p>\n</blockquote>\n</li>\n<li><p>KVC的底层实现？</p>\n<blockquote>\n<p>当一个对象调用setValue方法时，方法内部会做以下操作：<br>1). 检查是否存在相应的key的set方法，如果存在，就调用set方法。<br>2). 如果set方法不存在，就会查找与key相同名称并且带下划线的成员变量，如果有，则直接给成员变量属性赋值。<br>3). 如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值。<br>4). 如果还没有找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法。<br>这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。</p>\n</blockquote>\n</li>\n<li><p>ViewController生命周期</p>\n<blockquote>\n<p>按照执行顺序排列：<br>1). initWithCoder：通过nib文件初始化时触发。<br>2). awakeFromNib：nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每个对象。<br>3). loadView：开始加载视图控制器自带的view。<br>4). viewDidLoad：视图控制器的view被加载完成。<br>5). viewWillAppear：视图控制器的view将要显示在window上。<br>6). updateViewConstraints：视图控制器的view开始更新AutoLayout约束。<br>7). viewWillLayoutSubviews：视图控制器的view将要更新内容视图的位置。<br>8). viewDidLayoutSubviews：视图控制器的view已经更新视图的位置。<br>9). viewDidAppear：视图控制器的view已经展示到window上。<br>10). viewWillDisappear：视图控制器的view将要从window上消失。<br>11). viewDidDisappear：视图控制器的view已经从window上消失。</p>\n</blockquote>\n</li>\n<li><p>如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</p>\n<blockquote>\n<p>// 使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。<br>// 创建队列组<br>dispatch_group_t group = dispatch_group_create();<br>// 获取全局并发队列<br>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<br>dispatch_group_async(group, queue, ^{ /<em>加载图片1 </em>/ });<br>dispatch_group_async(group, queue, ^{ /<em>加载图片2 </em>/ });<br>dispatch_group_async(group, queue, ^{ /<em>加载图片3 </em>/ });<br>// 当并发队列组中的任务执行完毕后才会执行这里的代码<br>dispatch_group_notify(group, dispatch_get_main_queue(), ^{<br>// 合并图片<br>});</p>\n</blockquote>\n</li>\n<li><p>dispatch_barrier_async（栅栏函数）的作用是什么？</p>\n<blockquote>\n<p>函数定义：dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);<br>作用：<br>1.在它前面的任务执行结束后它才执行，它后面的任务要等它执行完成后才会开始执行。<br>2.避免数据竞争</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.创建并发队列</span><br><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\">// 2.向队列中添加任务</span><br><span class=\"line\">dispatch_async(queue, ^&#123;  // 1.2是并行的</span><br><span class=\"line\">    NSLog(@&quot;任务1, %@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_async(queue, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;任务2, %@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;dispatch_barrier_async(queue, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;任务 barrier, %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;dispatch_async(queue, ^&#123;   // 这两个是同时执行的</span><br><span class=\"line\">    NSLog(@&quot;任务3, %@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_async(queue, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;任务4, %@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出结果: 任务1 任务2 ——》 任务 barrier ——》任务3 任务4 </span><br><span class=\"line\">// 其中的任务1与任务2，任务3与任务4 由于是并行处理先后顺序不定。</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>原文链接：<a href=\"https://blog.csdn.net/gsl111000/article/details/93629640\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/gsl111000/article/details/93629640</a></p>\n<ol>\n<li><p>简单介绍下 NSURLConnection 类及+ sendSynchronousRequest:returningResponse:error:与– initWithRequest:delegate:两个方法的区别?</p>\n<blockquote>\n<p>答: NSURLConnection主要用于网络访问，其中+ sendSynchronousRequest:returningResponse:error:是同步访问数据，即当前线程会阻塞，并等待request的返回的response，而– initWithRequest:delegate:使用的是异步加载，当其完成网络访问后，会通过delegate回到主线程，并其委托的对象。</p>\n</blockquote>\n</li>\n<li><p>在项目什么时候选择使用GCD，什么时候选择NSOperation</p>\n<blockquote>\n<p>答: 项目中使用NSOperation的优点是NSOperation是对线程的高度抽象，在项目中使用它，会使项目的程序结构更好，子类化NSOperation的设计思路，是具有面向对象的优点(复用、封装)，使得实现是多线程支持，而接口简单，建议在复杂项目中使用。<br> 项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线程操作，会节省代码量，而Block参数的使用，会是代码更为易读，建议在简单项目中使用。</p>\n</blockquote>\n</li>\n<li><p>ViewController的didReceiveMemoryWarning怎么被调用</p>\n<blockquote>\n<p>答:[supper didReceiveMemoryWarning];</p>\n</blockquote>\n</li>\n<li><p>写一个setter方法用于完成@property(nonatomic, retain) NSString <em>name,写一个setter方法用于完成@property(nonatomic, copy) NSString </em>name</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setName:(NSString *)str&#123;</span><br><span class=\"line\">    [str retain];</span><br><span class=\"line\">    [_name release];</span><br><span class=\"line\">    _name = str;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)setName:(NSString *)str&#123;</span><br><span class=\"line\">    id t = [str copy];</span><br><span class=\"line\">    [_name release];</span><br><span class=\"line\">    _name = t;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对于语句NSString *obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?</p>\n<blockquote>\n<p>答： 编译时是NSString的类型;运行时是NSData类型的对象</p>\n</blockquote>\n</li>\n<li><p>Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?</p>\n<blockquote>\n<p>答：线程创建有三种方法：使用NSThread创建、使用GCD的dispatch、使用子类化的NSOperation,然后将其加入NSOperationQueue;在主线程执行代码，方法是performSelectorOnMainThread，如果想延时执行代码可以用performSelector:onThread:withObject:waitUntilDone:</p>\n</blockquote>\n</li>\n<li><p>浅复制和深复制的区别?</p>\n<blockquote>\n<p>答：浅层复制：只复制指向对象的指针，而不复制引用对象本身。<br>深层复制：复制引用对象本身。</p>\n</blockquote>\n</li>\n<li><p>PerformSelecter</p>\n<blockquote>\n<p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。<br>当调用performSelector:onThread:时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>\n</blockquote>\n</li>\n<li><p>优化你是从哪几方面着手？</p>\n<blockquote>\n<p>一、首页启动速度<br> 启动过程中做的事情越少越好（尽可能将多个接口合并）<br> 不在UI线程上作耗时的操作（数据的处理在子线程进行，处理完通知主线程刷新节目）<br> 在合适的时机开始后台任务（例如在用户指引节目就可以开始准备加载的数据）<br> 二、页面浏览速度<br> json的处理（iOS 自带的NSJSONSerialization，Jsonkit，SBJson）<br> 数据的分页（后端数据多的话，就要分页返回，例如网易新闻，或者 微博记录）<br> 数据压缩（大数据也可以压缩返回，减少流量，加快反应速度）<br> 内容缓存（例如网易新闻的最新新闻列表都是要缓存到本地，从本地加载，可以缓存到内存，或者数据库，根据情况而定）<br> 延时加载tab（比如app有5个tab，可以先加载第一个要显示的tab，其他的在显示时候加载，按需加载）<br> 算法的优化（核心算法的优化，例如有些app 有个 联系人姓名用汉语拼音的首字母排序）<br> 三、操作流畅度优化<br> Tableview 优化（tableview cell的加载优化）<br> ViewController加载优化（不同view之间的跳转，可以提前准备好数据）<br> 四、数据库的优化<br> 数据库设计上面的重构<br> 查询语句的优化<br> 分库分表（数据太多的时候，可以分不同的表或者库）<br> 五、服务器端和客户端的交互优化<br> 客户端尽量减少请求<br> 服务端尽量做多的逻辑处理<br> 服务器端和客户端采取推拉结合的方式（可以利用一些同步机制）<br> 通信协议的优化（减少报文的大小）<br> 电量使用优化（尽量不要使用后台运行）<br> 六、非技术性能优化<br> 产品设计的逻辑性（产品的设计一定要符合逻辑，或者逻辑尽量简单，否则会让程序员抓狂，有时候用了好大力气，才可以完成一个小小的逻辑设计问题）<br> 界面交互的规范（每个模块的界面的交互尽量统一，符合操作习惯）<br> 代码规范（这个可以隐形带来app 性能的提高，比如 用if else 还是switch ，或者是用！还是 ＝＝）<br> code review（坚持code Review 持续重构代码。减少代码的逻辑复杂度）</p>\n</blockquote>\n</li>\n<li><p>什么情况使用 weak 关键字，相比 assign 有什么不同？</p>\n<blockquote>\n<p>1.在ARC中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性。<br>2.自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,如自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。<br>IBOutlet连出来的视图属性为什么可以被设置成weak?<br>答：因为父控件的subViews数组已经对它有一个强引用。<br>不同点<br>assign 可以用非 OC 对象，而 weak 必须用于 OC 对象。<br>weak 表明该属性定义了一种“非拥有关系”。在属性所指的对象销毁时，属性值会自动清空(nil)</p>\n</blockquote>\n</li>\n<li><p>用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？</p>\n<blockquote>\n<p>答：用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的），为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。<br>1.因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。<br>2.如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。<br>总结：使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发送变化会无意间篡改不可变类型对象原来的值。</p>\n</blockquote>\n</li>\n<li><p>runtime如何实现weak变量的自动置nil？</p>\n<blockquote>\n<p>runtime对注册的类，会进行布局，会将 weak 对象放入一个 hash 表中。用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会调用对象的 dealloc 方法，假设 weak 指向的对象内存地址是a，那么就会以a为key，在这个 weak hash表中搜索，找到所有以a为key的 weak 对象，从而设置为nil</p>\n</blockquote>\n</li>\n<li><p>runloop是什么／runloop的概念？</p>\n<blockquote>\n<p>runloop是线程相关的基础框架的一部分。一个runloop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。其实内部就是do－while循环，这个循环内部不断地处理各种任务（比如Source，Timer，Observer）。使用runloop的目的是让你的线程在有工作的时候忙于工作，而没工作的时候处于休眠状态。</p>\n</blockquote>\n</li>\n<li><p>UITableViewCell上有个UILabel，显示NSTimer实现的秒表时间，手指滚动cell过程中，label是否刷新，为什么？</p>\n<blockquote>\n<p>这是否刷新取决于timer加入到Run Loop中的Mode是什么。Mode主要是用来指定事件在运行循环中的优先级的，分为<br>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态<br>UITrackingRunLoopMode：ScrollView滑动时会切换到该Mode<br>UIInitializationRunLoopMode：run loop启动时，会切换到该mode<br>NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合<br>苹果公开提供的Mode有两个<br>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）<br>NSRunLoopCommonModes（kCFRunLoopCommonModes）<br>在编程中：如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。当我们滚动的时候，也希望不调度，那就应该使用默认模式。但是，如果希望在滚动时，定时器也要回调，那就应该使用common mode。</p>\n</blockquote>\n</li>\n<li><p>NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?</p>\n<blockquote>\n<p>不准；不准的原因如下<br>1、NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。<br>2、模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。<br>当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个ScrollView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。所以就会影响到NSTimer不准的情况。<br>PS:DefaultMode 是 App 平时所处的状态，rackingRunLoopMode 是追踪 ScrollView 滑动时的状态。<br>方法：<br>1、在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中。避免被复杂运算操作或者UI界面刷新所干扰self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(showTime) userInfo:nil repeats:YES];<br>[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];<br>2、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(void)timerMethod2 &#123;</span><br><span class=\"line\">    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];</span><br><span class=\"line\">    [thread start];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">-(void)newThread&#123;</span><br><span class=\"line\">    @autoreleasepool&#123;</span><br><span class=\"line\">        [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(showTime) userInfo:nil repeats:YES];</span><br><span class=\"line\">        [[NSRunLoop currentRunLoop] run];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>NSOperation 相比于 GCD 有哪些优势？</p>\n<blockquote>\n<p>GCD是基于c的底层api，NSOperation属于object-c类。ios 首先引入的是NSOperation，IOS4之后引入了GCD和NSOperationQueue并且其内部是用gcd实现的。<br>相对于GCD：<br>1、NSOperation拥有更多的函数可用，具体查看api。<br>2、在NSOperationQueue中，可以建立各个NSOperation之间的依赖关系。<br>3、有kvo可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）。<br>4、NSOperationQueue可以方便的管理并发、NSOperation之间的优先级。<br>GCD主要与block结合使用。代码简洁高效。<br>GCD也可以实现复杂的多线程应用，主要是建立个个线程时间的依赖关系这类的情况，但是需要自己实现相比NSOperation要复杂。<br>具体使用哪个，依需求而定。 从个人使用的感觉来看，比较合适的用法是：除了依赖关系尽量使用GCD，因为苹果专门为GCD做了性能上面的优化。</p>\n</blockquote>\n</li>\n<li><p>如何访问并修改一个类的私有属性?</p>\n<blockquote>\n<p>有两种方法可以访问私有属性,一种是通过KVC获取,一种是通过runtime访问并修改私有属性。</p>\n</blockquote>\n</li>\n<li><p>如何捕获异常？</p>\n<blockquote>\n<p>1.在app启动时(didFinishLaunchingWithOptions)，添加一个异常捕获的监听<br>NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);<br>2.实现捕获异常日志并保存到本地的方法</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void UncaughtExceptionHandler(NSException *exception)&#123;</span><br><span class=\"line\">    //异常日志获取</span><br><span class=\"line\">    NSArray  *excpArr = [exception callStackSymbols];</span><br><span class=\"line\">    NSString *reason = [exception reason];</span><br><span class=\"line\">    NSString *name = [exception name];</span><br><span class=\"line\">    NSString *excpCnt = [NSString stringWithFormat:@&quot;exceptionType: %@ \\n reason: %@ \\n stackSymbols: %@&quot;,name,reason,excpArr];</span><br><span class=\"line\">    //日常日志保存（可以将此功能单独提炼到一个方法中）</span><br><span class=\"line\">    NSArray  *dirArr  = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class=\"line\">    NSString *dirPath = dirArr[0];</span><br><span class=\"line\">    NSString *logDir = [dirPath stringByAppendingString:@&quot;/CrashLog&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">    BOOL isExistLogDir = YES;</span><br><span class=\"line\">    NSFileManager *fileManager = [NSFileManager defaultManager];</span><br><span class=\"line\">    if (![fileManager fileExistsAtPath:logDir]) &#123;</span><br><span class=\"line\">        isExistLogDir = [fileManager createDirectoryAtPath:logDir withIntermediateDirectories:YES attributes:nil error:nil];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (isExistLogDir) &#123;</span><br><span class=\"line\">        //此处可扩展</span><br><span class=\"line\">        NSString *logPath = [logDir stringByAppendingString:@&quot;/crashLog.txt&quot;];</span><br><span class=\"line\">        [excpCnt writeToFile:logPath atomically:YES encoding:NSUTF8StringEncoding error:nil];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Object-c的类可以多重继承么?可以实现多个接口么?Category是什么?重写一个类的方式用继承好还是分类好?为什么?</p>\n<blockquote>\n<p>答：Object-c的类不可以多重继承;可以实现多个接口，通过实现多个接口可以完成C++的多重继承;Category是类别，一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。</p>\n</blockquote>\n</li>\n<li><p>Category(分类)，Extension(扩展)和继承的区别</p>\n<blockquote>\n<p>答：1.分类<br>category原则上只能在现有类基础上添加新的方法（能添加属性的原因只是通过runtime解决无setter/getter的问题而已），类别中的方法没被实现编译器是不会有任何警告的，这是因为类别是在运行时添加到类中的<br>2.扩展<br>iOS中的extension就是匿名的分类，只有头文件没有实现文件。类扩展不仅可以增加方法，还可以增加实例变量（或者属性），只是该实例变量默认是@private类型的（使用范围只能在自身类，而不是子类或其他地方），类扩展中声明的方法没被实现，编译器会报警，这是因为类扩展是在编译阶段被添加到类中的<br>3.继承<br>在iOS中继承是单继承，既只能有一个父类。在继承中，子类可以使用父类的方法和变量，当子类想对本类或者父类的变量进行初始化，那么需要重写init()方法 。父类也可以访问子类的方法和成员变量</p>\n</blockquote>\n</li>\n<li><p>简述内存分区情况</p>\n<blockquote>\n<p>1). 代码区：存放函数二进制代码<br>2). 数据区：系统运行时申请内存并初始化，系统退出时由系统释放。存放全局变量、静态变量、常量<br>3). 堆区：通过malloc等函数或new等操作符动态申请得到，需程序员手动申请和释放<br>4). 栈区：函数模块内申请，函数结束时由系统自动释放。存放局部变量、函数参数</p>\n</blockquote>\n</li>\n<li><p>直接调用_objc_msgForward函数将会发生什么？</p>\n<blockquote>\n<p>_objc_msgForward是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。<br>直接调用_objc_msgForward是非常危险的事，如果用不好会直接导致程序Crash，但是如果用得好，能做很多非常酷的事。<br>一旦调用_objc_msgForward，将跳过查找 IMP 的过程，直接触发“消息转发”，如果调用了_objc_msgForward，即使这个对象确实已经实现了这个方法，你也会告诉objc_msgSend：“我没有在这个对象里找到这个方法的实现”</p>\n</blockquote>\n</li>\n<li><p>对于Run Loop的理解</p>\n<blockquote>\n<p>RunLoop，是多线程的法宝，即一个线程一次只能执行一个任务，执行完任务后就会退出线程。主线程执行完即时任务时会继续等待接收事件而不退出。非主线程通常来说就是为了执行某一任务的，执行完毕就需要归还资源，因此默认是不运行RunLoop的；<br>每一个线程都有其对应的RunLoop，只是默认只有主线程的RunLoop是启动的，其它子线程的RunLoop默认是不启动的，若要启动则需要手动启动；<br>在一个单独的线程中，如果需要在处理完某个任务后不退出，继续等待接收事件，则需要启用RunLoop；<br>NSRunLoop提供了一个添加NSTimer的方法，可以指定Mode，如果要让任何情况下都回调，则需要设置Mode为Common模式；<br>实质上，对于子线程的runloop默认是不存在的，因为苹果采用了懒加载的方式。如果我们没有手动调用[NSRunLoop currentRunLoop]的话，就不会去查询是否存在当前线程的RunLoop，也就不会去加载，更不会创建。</p>\n</blockquote>\n</li>\n<li><p>runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</p>\n<blockquote>\n<p>1.每一个类对象中都一个对象方法列表（对象方法缓存）<br>2.类方法列表是存放在类对象中isa指针指向的元类对象中（类方法缓存）<br>3.方法列表中每个方法结构体中记录着方法的名称,方法实现,以及参数类型，其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.<br>4.当我们发送一个消息给一个NSObject对象时，这条消息会在对象的类对象方法列表里查找<br>5.当我们发送一个消息给一个类时，这条消息会在类的Meta Class对象的方法列表里查找</p>\n</blockquote>\n</li>\n<li><p>runtime 中，SEL 和 IMP 的区别</p>\n<blockquote>\n<p>方法名 SEL – 表示该方法的名称；<br>IMP – 指向该方法的具体实现的函数指针，说白了IMP就是实现方法。</p>\n</blockquote>\n</li>\n<li><p>block底层实现</p>\n<blockquote>\n<p>block本质是指向一个结构体的一个指针<br>运行时机制 比较高级的特性 纯C语言<br>平时写的OC代码 转换成C语言运行时的代码<br>指令:clang -rewrite-objc main.m(可以打印验证)<br>默认情况下,任何block都是在栈里面的,随时可能被回收<br>只要对其做一次copy操作 block的内存就会放在堆里面 不会释放<br>只有copy才能产生一个新的内存地址 所有地址会发生改变</p>\n</blockquote>\n</li>\n<li><p>TCP协议三次握手</p>\n<blockquote>\n<p>TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志——SYN(synchronize)和ACK(acknowledgement)。发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。</p>\n</blockquote>\n</li>\n<li><p>@property 的本质是什么？</p>\n<blockquote>\n<p>@property = ivar + getter + setter;<br>“属性” (property)有两大概念：ivar（实例变量）、getter+setter（存取方法）</p>\n</blockquote>\n</li>\n<li><p>KVC的底层实现？</p>\n<blockquote>\n<p>当一个对象调用setValue方法时，方法内部会做以下操作：<br>1). 检查是否存在相应的key的set方法，如果存在，就调用set方法。<br>2). 如果set方法不存在，就会查找与key相同名称并且带下划线的成员变量，如果有，则直接给成员变量属性赋值。<br>3). 如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值。<br>4). 如果还没有找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法。<br>这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。</p>\n</blockquote>\n</li>\n<li><p>ViewController生命周期</p>\n<blockquote>\n<p>按照执行顺序排列：<br>1). initWithCoder：通过nib文件初始化时触发。<br>2). awakeFromNib：nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每个对象。<br>3). loadView：开始加载视图控制器自带的view。<br>4). viewDidLoad：视图控制器的view被加载完成。<br>5). viewWillAppear：视图控制器的view将要显示在window上。<br>6). updateViewConstraints：视图控制器的view开始更新AutoLayout约束。<br>7). viewWillLayoutSubviews：视图控制器的view将要更新内容视图的位置。<br>8). viewDidLayoutSubviews：视图控制器的view已经更新视图的位置。<br>9). viewDidAppear：视图控制器的view已经展示到window上。<br>10). viewWillDisappear：视图控制器的view将要从window上消失。<br>11). viewDidDisappear：视图控制器的view已经从window上消失。</p>\n</blockquote>\n</li>\n<li><p>如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</p>\n<blockquote>\n<p>// 使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。<br>// 创建队列组<br>dispatch_group_t group = dispatch_group_create();<br>// 获取全局并发队列<br>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<br>dispatch_group_async(group, queue, ^{ /<em>加载图片1 </em>/ });<br>dispatch_group_async(group, queue, ^{ /<em>加载图片2 </em>/ });<br>dispatch_group_async(group, queue, ^{ /<em>加载图片3 </em>/ });<br>// 当并发队列组中的任务执行完毕后才会执行这里的代码<br>dispatch_group_notify(group, dispatch_get_main_queue(), ^{<br>// 合并图片<br>});</p>\n</blockquote>\n</li>\n<li><p>dispatch_barrier_async（栅栏函数）的作用是什么？</p>\n<blockquote>\n<p>函数定义：dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);<br>作用：<br>1.在它前面的任务执行结束后它才执行，它后面的任务要等它执行完成后才会开始执行。<br>2.避免数据竞争</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.创建并发队列</span><br><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\">// 2.向队列中添加任务</span><br><span class=\"line\">dispatch_async(queue, ^&#123;  // 1.2是并行的</span><br><span class=\"line\">    NSLog(@&quot;任务1, %@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_async(queue, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;任务2, %@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;dispatch_barrier_async(queue, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;任务 barrier, %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;dispatch_async(queue, ^&#123;   // 这两个是同时执行的</span><br><span class=\"line\">    NSLog(@&quot;任务3, %@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_async(queue, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;任务4, %@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出结果: 任务1 任务2 ——》 任务 barrier ——》任务3 任务4 </span><br><span class=\"line\">// 其中的任务1与任务2，任务3与任务4 由于是并行处理先后顺序不定。</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck1k3jkti0003jz6yzssukpwa","tag_id":"ck1k3jkty0007jz6yydwewltt","_id":"ck1k3jkut0009jz6ygdq7v3nk"},{"post_id":"ck1k3jktm0006jz6yngqeprnk","tag_id":"ck1k3jkua0008jz6yk4ns0tuu","_id":"ck1k3jkuu000ajz6yzkj5fkhl"}],"Tag":[{"name":"iOS","_id":"ck1k3jkty0007jz6yydwewltt"},{"name":"证书","_id":"ck1k3jkua0008jz6yk4ns0tuu"}]}}